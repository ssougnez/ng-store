<main>
    <div class="logo">

        <div class="title">
            <span>ng-st</span>
            <img src="assets/img/logo.svg"
                 alt="Logo" />
            <span>re</span>
        </div>
    </div>

    <h1>Table of content</h1>

    <ul>
        <li><a href="#context">Context</a></li>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#playground">PLayground</a></li>
        <li><a href="#installation">Installation</a></li>
        <li><a href="#principle">Principle</a></li>
        <li><a href="#models">Models</a></li>
        <li><a href="#state">State</a></li>
        <li><a href="#configuration">Configuration</a></li>
        <li><a href="#find">Find</a></li>
        <li><a href="#select">Select</a></li>
        <li><a href="#indexes">Indexes</a></li>
        <li><a href="#upsert">Update</a></li>
        <li><a href="#remove">Remove</a></li>
        <li><a href="#load">Load</a></li>
        <li><a href="#post">Post</a></li>
        <li><a href="#put">Put</a></li>
        <li><a href="#delete">Delete</a></li>
        <li><a href="#ngs-container">ngs-container</a></li>
        <li><a href="#store-component">StoreComponent</a></li>
        <li><a href="#roadmap">Roadmap</a></li>
    </ul>

    <h1 id="context">Context</h1>

    <p>Managing data in an Angular application can be quite tricky and impact the way you develop your application.
        "ng-store" is a solution to manage data using a store similar to a relational database.</p>

    <h1 id="introduction">Introduction</h1>

    <p>When learning Angular, you'll be confronted to a lot of concepts and challenges that you'll have to take.
        There are so many of those that beginners tend to neglect one of the most important: data management.</p>

    <p>At first, it's tempting to rush into components development to make huge and complex components to power your
        application. After all, at first, it seems easier to have everything in a huge component. However, after a
        while, it appears that it is not a good solution and that it brings more problem that it solves.</p>

    <p>At some point, in the Angular learning journey, one will be confronted to the challenge of managing data in the
        best way possible. At first, it's most likely that one will store data inside a component. Basically, after
        having read some tutorials, one will inject the <code class="language-typescript">HttpClient</code> service into
        the component and call the <code class="language-typescript">get</code> method to fetch data before displaying
        them on the screen.</p>

    <p>It obviously works pretty well, however, there are some attention points to this:</p>

    <ul>
        <li>
            In a perfect world, a component should do one and only one thing. Therefore, fetching data using a HTTP call
            and displaying them could be considered as two things => bad practice.
        </li>
        <li>
            Data loaded in the component are only available in this component.
        </li>
        <li>
            You might need multiple class variables to store these data depending on the complexity of the component.
        </li>
        <li>
            If multiple components need the same data, they will be loaded multiple times.
        </li>
    </ul>

    <p>The next logical step is to start using services to store data. There are avantages to this approach:</p>

    <ul>
        <li>
            Data are centralized: When data are loaded, they are available to multiple components.
        </li>
        <li>
            The heavy lifting is done once by the service. Components needing the data just have to inject the
            service and use the data.
        </li>
    </ul>

    <p>
        However, it's still, in my opinion, not the perfect solution. Indeed, with services maintaining their own data
        arise some pain points:
    </p>

    <ul>
        <li>
            What if the service A needs data from the services B and vice versa. This will create a cyclic dependency
            that will be difficult to solve properly.
        </li>
        <li>
            It's difficult to ensure that services fetch and maintain their data in the same way. This can be leveraged
            using a base class but it adds some complexity.
        </li>
        <li>
            If you're using the "OnPush" change detection strategy (as you should), simply updating data in a service
            won't refresh the views that depend on its data. Indeed, you'll need to implement a system propagating the
            value change down to the components. It's not very complex but it adds unecessary boilerplate.
        </li>
        <li>
            You still have to think and implement a way of fetching data from your back end in a consistent way.
        </li>
    </ul>

    <p>
        I faced all these issues and considerations in my day to day work for a while, which is why I decided to have a
        look at store/state management systems out there.
    </p>

    <p>To be honest, I only checked one out: <a href="https://ngrx.io/"
           target="_blank">ngrx</a>. Mostly because it's the most popular one.
    </p>

    <p>
        Before reading the following lines, please consider that I didn't use it for a long time and I probably only
        scratched the surface so the following lines might not be entirely correct or can be outdated.
    </p>

    <p>
        My general feeling about this library is that it is waaay too complex to use. You have to create actions,
        effects, reducers, selectors, etc... and at the end, everything ties up magically and it becomes pretty
        cumbersome to have a clear view of what's happening in your application or to debug it.
    </p>

    <p>
        Another issue I had with it was the way immutability is handled. Basically, you have to do the heavy lifting
        using the spread operator in order to create new objects based on existing ones. I found it pretty cumbersome
        and not very intuitive (spoiler alert: "ng-store" handles it in a way that is totally transparent to you).
    </p>

    <p>
        Once again, I'm sure it's a perfectly good library but long story short, it didn't suit me.
    </p>

    <p>
        However, I really liked the idea of having one common location to store all the data of the application.
        Besides, the reactivity of the store also charmed me a lot, which is why I decided to implement my own store
        management library.
    </p>

    <p>
        At the time of writing (2023), I've been working on and using this library for two years and now that it is
        stable, I feel that it can be useful to other developers than me.
    </p>

    <p>
        In this documentation, we'll see the basic principle behind ng-store, how to configure and use it. After
        reading, you'll know everything there is about it and if you liked what you read, maybe you'll want to use it in
        your app ðŸ˜€
    </p>

    <h1 id="playground">Playground</h1>

    <p>You can find the code of the examples we'll talk about later in this article in the <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src"
           target="_blank">GitHub playground</a>. The only thing you need to do is update the line 6 of the "main.ts"
        file to change the example you want to build.</p>

    <h1 id="installation">Installation</h1>

    <p>Simply run:</p>

    <pre><code class="language-typescript">yarn add immer @ssougnez/ng-store</code></pre>

    <h1 id="principle">Principle</h1>

    <p>
        You can use "ng-store" the way you want, however, you'll find in this section some advices to use it in an
        optimal way.
    </p>

    <p>
        Basically, the main principle consists in using "flat objects" as musch as possible. What I call "flat objects"
        are objects without any complex properties other than ones containing abstract data. For example, this is not a
        "flat object":</p>

    <pre>
<code class="language-typescript">{{ '{' }}
    firstName: "Nicolas",
    lastName: "Cage",
    age: 50,
    friends: [{{ '{' }}
        firstName: "Nicole",
        lastName: "Kidman",
        age: 56
    }]
}</code></pre>

    <p>
        The issue with this kind of objet is that it is an open door to data redundancy. Indeed, say that you fetch
        these data from a back end using REST API. It is very likely that the different users will have the same
        friends, meaning that a user data might be located in the "friends" array of multiple objects, causing the data
        to be bigger and duplicated. A better version of it would be:
    </p>

    <pre>
<code class="language-typescript">{{ '{' }}
    firstName: "Nicolas",
    lastName: "Cage",
    age: 50,
    friends: [3, 19, 5]
}</code></pre>

    <p>
        In this approach, objects are treated as <strong>entities</strong> identified by a specific property that do not
        contain complex properties other than abstract data. "Abstract data" are data that does not represent entities
        in themselves, for example, some configuration for a specific entity.
    </p>

    <p>
        Basically, you have to think about entities as rows in a relational database. In these, you have regular columns
        storing simple data and when you need more complex data, you store them in another table referenced by a foreign
        key in your primary one. In some circunstance, you'll also create a text column storing abstract data (in JSON).
    </p>

    <p>
        Following this principle will help you a lot using "ng-store", but also for working on your back end. Indeed,
        when you have no real guidelines about the form of the object to return via a web service, it can be difficult
        to know what data to fetch from the database because you're not sure what data will be needed by the REST API
        call. With this approach, most of the time, you'll fetch data from your database in the most basic way.
    </p>

    <h1 id="models">Models</h1>

    <p>
        The core concept of the store is "entities". As explained above, an entity is a basic object with only
        simple properties. It must also contain an "id" property of the type you want. To ensure this last requirement,
        all your entities need to extend the <code class="language-typescript">BaseEntity&lt;T></code> base class
        where "T" is the type of the "id" property. For example, here is an example of a "Pokemon" entity.
    </p>

    <pre>
<code class="language-typescript">import {{ '{' }} BaseEntity } from "@ssougnez/ng-store";

export type Pokemon = BaseEntity&lt;number> & {{ '{' }}
    name: string;
    type: 'water' | 'fire' | 'electric' | 'grass' | 'bug' | 'normal' | 'poison';
}</code></pre>

    <p>
        It's important to highlight the fact that these entities are not stored as such in the store. In the example
        above, a value of type "Pokemon" will be stored as an <code
              class="language-typescript">Entity&lt;Pokemon></code> object. This type
        allows ng-store to store and find values in an efficient way. For now, the most important thing to remember is
        that an object of type <code class="language-typescript">Entity&lt;T></code> contains a <code
              class="language-typescript">value</code> property that holds the actual <code
              class="language-typescript">Pokemon</code> object. The type <code
              class="language-typescript">Entity&lt;T></code> also contains other properties that we'll review later in
        this document.
    </p>

    <p>
        For the rest of this article, we'll use the following terms:
    </p>

    <ul>
        <li><strong>value</strong>: A value is the object you want to store, in this case, a "Pokemon" object.</li>
        <li><strong>entity</strong>: An entity is a value wrapped in a <code
                  class="language-typescript">Entity&lt;T></code> object.</li>
    </ul>

    <h1 id="state">State</h1>

    <p>
        Now that we have an entity, we can create our state. A state is composed by a type defined its shape and its
        initial value. Let's start by the shape of the state. In this example, it will simply contain a section called
        "pokemons". A section can be seen as a table in a database. It stores data of the same type.
    </p>

    <p>
        I usually create the state in a file called "app.state" located in a "states" directory.
    </p>

    <pre>
<code class="language-typescript">import {{ '{' }} Pokemon } from "../models/pokemon.model";

export type AppState = {{ '{' }}
    pokemons: Entities&lt;Pokemon>;
}</code></pre>

    <p>
        Along with the shape of the state, we need to defined its initial value. In the same file, add the following
        lines:
    </p>

    <pre>
<code class="language-typescript">import {{ '{' }} createEntities, Entities } from "@ssougnez/ng-store";
    
    export const initial: AppState = {{ '{' }}
        pokemons: createEntities()
    }</code></pre>

    <p>
        "createEntities" is a function that creates an empty section in your store.
    </p>

    <h1 id="configuration">Configuration</h1>

    <p>
        The last step required to use the start is simply to inject it in your module and configure it to use the
        default value of your store.
    </p>

    <p class="message information">
        As ng-store is not yet standalone compatible, you have to import "NgStoreModule" in the components using it.
        However, the standalone support is one of the next feature planned.
    </p>

    <pre>
<code class="language-typescript">@NgModule({{ '{' }}
    imports: [
      NgStoreModule
    ],
    providers: [
      {{ '{' }}
        provide: NG_STORE_CONFIG,
        useValue: {{ '{' }}
          initialValue: initial,
          httpClientType: null
        } as StoreConfiguration
      }
    ]
  })
  export class AppModule {{ '{' }} }
</code></pre>

    <p>
        The configuration object accepts other properties but we'll cover them later in this documentation.
    </p>

    <p>
        ng-store supports loading data asynchronously using HTTP requests. To use this feature, you can either not
        define the <code class="language-typescript">httpClientType</code> to use the default HTTP client of Angular or
        define it on a custom class (more on that later).
    </p>

    <h1 id="find">Find functions</h1>

    <p>
        Find functions are used to find entities or values in the store. Let's start by updating the initial state of
        the store in order to insert some data.
    </p>

    <pre>
<code class="language-typescript">export const initial: AppState = {{ '{' }}
    pokemons: createEntities&lt;Pokemon>([
        {{ '{' }}
            id: 1,
            name: 'Pikachu',
            type: 'electric'
        },
        {{ '{' }}
            id: 2,
            name: 'Bulbasaur',
            type: 'grass'
        },
        {{ '{' }}
            id: 3,
            name: 'Charmander',
            type: 'fire'
        },
        {{ '{' }}
            id: 4,
            name: 'Charmander',
            type: 'fire'
        },
        {{ '{' }}
            id: 5,
            name: 'Squirtle',
            type: 'water'
        },
        {{ '{' }}
            id: 6,
            name: 'Caterpie',
            type: 'bug'
        },
        {{ '{' }}
            id: 7,
            name: 'Weedle',
            type: 'bug'
        },
        {{ '{' }}
            id: 8,
            name: 'Pidgey',
            type: 'normal'
        },
        {{ '{' }}
            id: 9,
            name: 'Nidoran',
            type: 'normal'
        },
        {{ '{' }}
            id: 10,
            name: 'Rattata',
            type: 'normal'
        },
        {{ '{' }}
            id: 11,
            name: 'Spearow ',
            type: 'normal'
        },
        {{ '{' }}
            id: 12,
            name: 'Ekans ',
            type: 'poison'
        }
    ])
}</code></pre>

    <p>
        Here's the ncessary code used to retrieve all the pokemons from the store:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent {{ '{' }}

  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public pokemons: Pokemon[] = this._store.getValues(s => s.pokemons);
  public trackByValue: TrackByFunction&lt;Pokemon> = trackByValue;

}</code></pre>

    <p>
        We're using the <code class="language-typescript">getValues</code> function to returns all the values stored in
        the "pokemons" section of the store. The <code class="language-typescript">trackByValue</code> variable is a
        function proposed by ng-store to tell <code class="language-typescript">ngFor</code> to use the "id" property of
        array values.
    </p>

    <pre>
<code class="language-xml">&lt;h1>Pokemon&lt;/h1>

&lt;div *ngFor="let pokemon of pokemons; trackBy: trackByValue">{{ '{' + '{' }} pokemon.name }}&lt;/div></code></pre>

    <p>The result being:</p>

    <div class="img">
        <img src="assets/img/get-values.png" />
    </div>

    <p>
        Now, to understand the difference between an entity and its value, let's use this variation of the code:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent {{ '{' }}

  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public pokemons: Entity&lt;Pokemon>[] = this._store.getEntities(s => s.pokemons);
  public trackByEntity: TrackByFunction&lt;Entity&lt;Pokemon>> = trackByEntity;

}</code></pre>

    <pre>
<code class="language-xml">&lt;h1>Pokemon&lt;/h1>
    
&lt;div *ngFor="let pokemon of pokemons; trackBy: trackByEntity">{{ '{' + '{' }} pokemon | json }}&lt;/div></code></pre>

    <p>
        This time, the result is:
    </p>

    <div class="img">
        <img src="assets/img/get-entities.png" />
    </div>

    <p>
        As you can see, an entity is an object with a <code class="language-typescript">value</code> property that
        contains the actual object you want to use. It also contains other properties used by "ng-store" to maintain the
        store in a correct state. Besides, we'll see later in this document that you can use some of these properties to
        update the UI of your component depending on the state of the entities in the store.
    </p>

    <p class="message information">
        In this case, we used <code class="language-typescript">trackByEntity</code> as we're dealing with entities.
    </p>

    <p>
        It is also possible to find a value or an entity in the store based on its "id" using the <code
              class="language-typescript">findValueByKey</code> or <code
              class="language-typescript">findEntityByKey</code>. For example, here is how you would find the pokemon
        with the "id" 1.
    </p>

    <pre>
<code class="language-typescript">public firstValue: Pokemon | null = this._store.findValueByKey(s => s.pokemons, 1);
public firstEntity: Entity&lt;Pokemon> | null = this._store.findEntityByKey(s => s.pokemons, 1);</code></pre>

    <p>
        Note that these functions return <code class="language-typescript">null</code> if the entity cannot be found.
    </p>

    <p>
        It is also possible to find values by any other criteria using the functions <code
              class="language-typescript">findValuesBy</code> or <code
              class="language-typescript">findEntitiesBy</code>. In the following example, we'll find all "normal"
        pokemons.
    </p>

    <pre>
<code class="language-typescript">public normalValues: Pokemon[] = this._store.findValuesBy(s => s.pokemons, p => p.type === 'normal');
public normalEntities: Entity&lt;Pokemon>[] = this._store.findEntitiesBy(s => s.pokemons, e => e.value.type === 'normal');</code></pre>

    <p class="message warning">
        Even though the code above works, it's recommanded and more performant to use <a href="#indexes">indexes</a> as
        much as possible to find values based on another property than the "id".
    </p>

    <p>
        You can also use the functions <code class="language-typescript">findEntityBy</code> and <code
              class="language-typescript">findValueBy</code> to find the first entity or value matching the condition.
    </p>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/01_Find"
           target="_blank">this example</a> of the playground.
    </p>

    <h1 id="select">Select functions</h1>

    <p>
        In the previous chapter, we saw how to retrieve values from the store. Even though it works, there is something
        you need be aware of: The store is <strong>immutable</strong>. You can confirm this by trying to do something
        like this:
    </p>

    <pre>
<code class="language-typescript">let pokemon: Pokemon | null = this._store.findValueByKey(s => s.pokemons, 1);

if (pokemon !== null) {{ '{' }}
  pokemon.name = 'Super pikachu';
}</code></pre>

    <p>
        The code above would produce the following error in the console:
    </p>

    <div class="img">
        <img src="assets/img/immutable-error.png" />
    </div>

    <p>
        Indeed, values in the store are <strong>immutable</strong>, which means that you cannot directly update them
        like
        in the example above. If you never used immutability, it can seem weird but I strongly advice you to read on the
        subject to understand why it is a better idea to store the object like this.
    </p>

    <p>
        There are multiple ways to ensure immutability in JavaScript and ng-store uses an awesome library called <a
           href="https://github.com/immerjs/immer"
           target="_blank">immer</a>. I won't talk about this library in here but I strongly advice you to have a look
        at it if you want to understand how ng-store works under the hood.
    </p>

    <p>
        One important consequence of immutability is that objects that you retrieve from the store using <a
           href="find">find functions</a> might not always display the most up to date data. Indeed, say you
        get a value from the store using a find function. If this value changes in the store, your component will still
        hold a reference to the same object, so the one that hasn't been modified (as the modification triggers the
        creation of a new object), so you need to have a way to know when a value is modified in order to refresh your
        component accordingly, which is exactly what select functions are for.
    </p>

    <p>
        Basically, select functions are the same than find functions but they return observables instead of values or
        entities. For example:
    </p>

    <pre>
<code class="language-typescript">public values$: Observable&lt;Pokemon[]> = this._store.selectValues(s => s.pokemons);
public entities$: Observable&lt;Entity&lt;Pokemon>[]> = this._store.selectEntities(s => s.pokemons);</code></pre>

    <p>
        As you can see, you use <code class="language-typescript">selectValues</code> and <code
              class="language-typescript">selectEntities</code> the same way you use <code
              class="language-typescript">getValues</code> and <code class="language-typescript">getEntities</code>. The
        only difference is that these functions return an observable instead of the values or entities. As for the
        templates, the code is almost the same.
    </p>

    <pre>
<code class="language-xml">&lt;h1>Values&lt;/h1>

&lt;div *ngFor="let pokemon of values$ | async; trackBy: trackByValue">{{ '{' + '{' }} pokemon | json }}&lt;/div>

&lt;h1>Entities&lt;/h1>

&lt;div *ngFor="let pokemon of entities$ | async; trackBy: trackByEntity">{{ '{' + '{' }} pokemon | json }}&lt;/div></code></pre>

    <p>
        The only difference here is that you have to use the <code class="language-typescript">async</code> pipe.
    </p>

    <p>
        Using the select functions, you ensure that your component will be notified each time a values that you
        retrieved changes. Another big advantage is that you can use the <code class="language-typescript">async</code>
        pipe to refresh the view of the component in a way supported by the "OnPush" change detection strategy.
    </p>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/02_Select"
           target="_blank">this example</a> of the playground.
    </p>

    <h1 id="indexes">Indexes</h1>

    <p>
        In the previous example, we saw how to select values based on another critera than their key. Even though it
        works, it's not optimal for performances. For example:
    </p>

    <pre>
<code class="language-typescript">public normal: Observable&lt;Pokemon[]> = this._store.selectValuesBy(s => s.pokemons, p => p.type === 'normal');</code></pre>

    <p>
        The issue here is that when the store gets updated, it will emit its new value, therefore, the predicate above
        will get executed for all pokemons once again.. If there are less than 10 000 items, it should be pretty fast,
        however, if your store contains a huge amount of pokemons, it can be pretty intensive to examine all of them to
        only return the normal ones. In this case, it is recommended to use indexes instead. Basically, an index is
        a property of the object that the store uses to organize its content in an efficient way.
    </p>

    <p>
        The first thing to do in order to use indexes is to define them when using <code
              class="language-typescript">createEntities</code>:
    </p>

    <pre>
<code class="language-typescript">export const initial: AppState = {{ '{' }}
    pokemons: createEntities&lt;Pokemon>([ ... ], ['type'])
}</code></pre>

    <p>
        Indexes are defined using the second parameter of <code class="language-typescript">createEntities</code> by
        passing an array of property names that will be used as indexes. It can be tempting to define every property
        in there but it is better to only defines the ones you'll really be using the most. Indeed, even though ng-store
        supports multiple indexes, maintaining them has a small cost, so it's better to avoid it if you don't need it.
    </p>

    <p>
        Now that we defined our index, we can simply used it via the functions <code
              class="language-typescript">findValuesByIndex</code> or <code
              class="language-typescript">selectValuesByIndex</code>:
    </p>

    <pre>
<code class="language-typescript">public normal: Observable&lt;Pokemon[]> = this._store.selectValuesByIndex(s => s.pokemons, 'type', 'normal');</code></pre>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/03_Indexes"
           target="_blank">this example</a> of the playground.
    </p>

    <h1 id="upsert">Upsert</h1>

    <p>
        Updating the store is pretty straightforward. In most scenario, data to add or update in the store are
        complete entities received by REST API, so you'll want to use the <code
              class="language-typescript">upsertValue</code> or <code class="language-typescript">upsertValues</code>
        functions. These functions add or update an object in the store based on its key. If an object with its key is
        already in the store, it will be merged with the one you pass to these functions. The only difference between
        these two functions is that <code class="language-typescript">upsertValues</code> expects an array and is used
        to upsert one or multiple values.
    </p>

    <p>
        Say that you have the following component:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent {{ '{' }}

  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public pokemons$: Observable&lt;Pokemon[]> = this._store.selectValues&lt;Pokemon>(s => s.pokemons).pipe(
    map(pokemons => pokemons.sort((p1, p2) => p1.name.localeCompare(p2.name)))
  );

  public trackByValue: TrackByFunction&lt;Pokemon> = trackByValue;

  public upsertNonExisting(): void {{ '{' }}

  }

  public upsertExisting(): void {{ '{' }}

  }

  public updateExisting(): void {{ '{' }}
    
  }
}</code></pre>

    <p>
        With the following template:
    </p>

    <pre>
<code class="language-xml">&lt;div *ngFor="let p of pokemons$ | async; trackBy: trackByValue">
    {{ '{' + '{' }} p.name }}
&lt;/div>

&lt;div>
    &lt;button (click)="upsertNonExisting()">Upsert non existing&lt;/button>
&lt;/div>
&lt;div>
    &lt;button (click)="upsertExisting()">Upsert existing&lt;/button>
&lt;/div>
&lt;div>
    &lt;button (click)="updateExisting()">Update existing&lt;/button>
&lt;/div></code></pre>

    <p>
        Nothing fancy, so far it simply selects all pokemons from the store, sort them in alphabetical order then
        display them. There are also three buttons. The first one upserts a new value in the store, the second one
        upserts a value that is already in the store (but with different data to show the effect) and the third
        one updates a property of a value.
    </p>

    <p>
        Here is the code of the first button:
    </p>

    <pre>
<code class="language-typescript">public upsertNonExisting(): void {{ '{' }}
  const pokemon: Pokemon = {{ '{' }}
    id: 13,
    name: 'Vulpix',
    type: 'fire'
  };

  this._store.upsertValue&lt;Pokemon>(s => s.pokemons, pokemon);
}</code></pre>

    <p>
        It does not get simpler than this. You just pass the new value to add in the store, and it gets added. Updating
        an existing value with another one is also very simple:
    </p>

    <pre>
<code class="language-typescript">public upsertExisting(): void {{ '{' }}
  const pokemon: Pokemon = {{ '{' }}
    id: 1,
    name: 'Zubat',
    type: 'poison'
  };

  this._store.upsertValue&lt;Pokemon>(s => s.pokemons, pokemon);
}</code></pre>

    <p>
        Here, we simply update the value with key 1 with a new value. However, it can happen that you don't have an
        object containing all the data of the entity you want to update, in this case, you can use the <code
              class="language-typescript">updateValueByKey</code> function to update an entity the way you want:
    </p>

    <pre>
<code class="language-typescript">public updateExisting(): void {{ '{' }}
  this._store.updateValueByKey(s => s.pokemons, 1, p => p.name = 'Jigglypuff');
}</code></pre>

    <p>
        Let see what the component displays at first:
    </p>

    <div class="img">
        <img src="assets/img/upsert-01.png" />
    </div>

    <p>
        Now, let's click on the first button:
    </p>

    <div class="img">
        <img src="assets/img/upsert-02.png" />
    </div>

    <p>
        Vulpix got added to the list and as we're using an observable, the view got refreshed automatically even though
        we're using the "OnPush" change detection strategy. Now, push the second button.
    </p>

    <div class="img">
        <img src="assets/img/upsert-03.png" />
    </div>

    <p>
        Pikachu disappeared and got replaced by Zubat. And finally, the third button:
    </p>

    <div class="img">
        <img src="assets/img/upsert-04.png" />
    </div>

    <p>
        Zubat got updated and became Jigglypuff.
    </p>

    <p>Besides these functions, you can also use the following ones:</p>

    <ul>
        <li><strong>updateEntitiesBy</strong>: Update <strong>entities</strong> based on a predicate.</li>
        <li><strong>updateEntityByKey</strong>: Update an <strong>entity</strong> based on its key.</li>
        <li><strong>updateValuesBy</strong>: Update <strong>values</strong> based on a predicate.</li>
    </ul>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/04_Upsert"
           target="_blank">this example</a> of the playground.
    </p>

    <h1 id="remove">Remove</h1>

    <p>
        Removing values from the store can be done using these two functions:
    </p>

    <ul>
        <li><strong>removeValuesBy</strong>: Removes values based on a predicate.</li>
        <li><strong>removeValuesByKeys</strong>: Removes values based on their key.</li>
    </ul>

    <p>
        For example, to remove the values with key 1 or 2:
    </p>

    <pre>
<code class="language-typescript">public remove(): void {{ '{' }}
    this._store.removeValuesByKeys&lt;Pokemon>(s => s.pokemons, 1, 2);
}</code></pre>

    <p>
        Or to remove all normal pokemons:
    </p>

    <pre>
<code class="language-typescript">public removeNormal(): void {{ '{' }}
    this._store.removeValuesBy(s => s.pokemons, p => p.type === 'normal');
}</code></pre>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/05_Remove"
           target="_blank">this example</a> of the playground.
    </p>

    <h1 id="load">Load</h1>

    <p>
        So far, we saw how to use the store in a synchronous way, however, in a real life scenario, data in the
        store get most of the time loaded using REST API in an asynchronous way. You could do it with what we saw above
        but ng-store comes with support for asynchronous loading of data. It also provides some components to
        simplify the UI. Let's start with a simple use case:
    </p>

    <ul>
        <li>Pokemons are loaded using a call to a REST API.</li>
        <li>We want to load all the pokemons but not all of their properties, to save bandwidth (partial load).</li>
        <li>We want a component to display a pokemon based on its id (all its properties).</li>
    </ul>

    <p>
        For those who want to run the examples from the playground, I'm using the "json-server" library to create a fake
        web service. You can start it by running the command <code class="language-typescript">yarn json</code> in
        the playground directory. All the call have a latency of one second in order to see what happens during the data
        loading.
    </p>

    <p>
        The first thing to do to be able to use HTTP calls is to configure "ng-store" in that way:
    </p>

    <pre>
<code class="language-typescript">@NgModule({{ '{' }}
    imports: [
        NgStoreModule,
        HttpClientModule
    ],
    providers: [
        {{ '{' }}
            provide: NG_STORE_CONFIG,
            useValue: {{ '{' }}
                initialValue: initial
            } as StoreConfiguration
        }
    ]
})
export class AppModule {{ '{' }} }
</code></pre>

    <p>
        We removed the "httpClientType" property to instruct Angular to use the default <code
              class="language-typescript">HttpClient</code> and we also imported the <code
              class="language-typescript">HttpClientModule</code>.
    </p>

    <p>
        Now, we're going to create a <code class="language-typescript">PokemonService</code> to do the heavy lifting of
        loading data:
    </p>

    <pre>
<code class="language-typescript">@Injectable({{ '{' }}
    providedIn: 'root'
})
export class PokemonService {{ '{' }}

    private _store: NgStore&lt;AppState> = inject(NgStore);

}</code></pre>

    <p>
        As we saw earlier, you could make the HTTP call by yourself and handle the loading, error and success states,
        but
        "ng-store" provides a component called <code class="language-typescript">ngs-container</code> to help you with
        that. Here, we'll see the most basic usage of this component, but you can find more information about it <a
           href="#ngs-container">later in this documentation</a>.
    </p>

    <p>
        This component works by using two observables:
    </p>

    <ul>
        <li><strong>query$</strong>: Used to perform the HTTP call.</li>
        <li><strong>data$</strong>: Retrieves the data you want to use in your template from the store.</li>
    </ul>

    <p>
        In our case, we'll start by implementing the function used to fetch data using a REST call in our service:
    </p>

    <pre>
<code class="language-typescript">public loadPokemons(): Observable&lt;Pokemon[]> {{ '{' }}
    return this._store.loadAllEntities('http://localhost:3000/pokemons', s => s.pokemons, false);
}</code></pre>

    <p>
        The <code class="language-typescript">loadAllEntities</code> function must be used to load all the entities from
        the server and put them in a store section. This function expects at most four parameters:
    </p>

    <ul>
        <li>
            <strong>url</strong>: URL to call to retrieve the data.
        </li>
        <li>
            <strong>root</strong>: predicate used to select the section of the store that will store the fetched data.
        </li>
        <li>
            <strong>entityLoaded</strong>: Define whether the loaded entities are complete or not (more on that a bit
            later).
        </li>
        <li>
            <strong>force</strong>: When data are loaded and put in the store, subsequents call to <code
                  class="language-typescript">loadAllEntities</code> for the same section will return them and not call
            the REST API again. However, you can force the store to refetch the data by setting this parameter to <code
                  class="language-typescript">true</code>.
        </li>
    </ul>

    <p>
        In this case, we use this function to call the web service at the specified URL and store the values returned by
        it in the "pokemons" section of the store. Moreover, as this route only returns <strong>some</strong> properties
        of
        the pokemons, we set the third parameter to <strong>false</strong> in order to indicate to the store that
        entities are loaded but not completely (we'll use that fact a bit later).
    </p>

    <p>
        Now that we have this function, we can update the code of our component like so:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent {{ '{' }}

  private readonly _pokemonService = inject(PokemonService);
  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public selectedId: number | null = null;

  public query$: Observable&lt;Pokemon[]> = this._pokemonService.loadPokemons();
  public pokemons$: Observable&lt;Pokemon[]> = this._store.selectValues&lt;Pokemon>(s => s.pokemons).pipe(
    map(pokemons => pokemons.sort((p1, p2) => p1.name.localeCompare(p2.name)))
  );

  public trackByValue: TrackByFunction&lt;Pokemon> = trackByValue;

}
</code></pre>

    <p>
        We simply set the <code class="language-typescript">query$</code> observable on the value returned by our
        service function and the <code class="language-typescript">data$</code> on a selection from the store. We also
        use the <code class="language-typescript">map</code> operator to sort the result based on the pokemons' name.
        Once we have these observables, we can use them in the template along with the <code
              class="language-typescript">ngs-container</code>. <code class="language-typescript">selectedId</code>
        variable will be used to display a pokemon in another component.
    </p>

    <pre>
<code class="language-xml">&lt;ngs-container [query$]="query$"
               [data$]="pokemons$"
               loaderType="text">
    &lt;ng-template let-pokemons>
        &lt;div class="flex-row flex-aic gap1"
             *ngFor="let p of pokemons; trackBy: trackByValue">
            &lt;div>{{ '{' + '{' }} p.name }}&lt;/div>
            &lt;i class="fa fa-solid fa-eye pointer"
               (click)="selectedId = p.id">&lt;/i>
        &lt;/div>
    &lt;/ng-template>
&lt;/ngs-container>
</code></pre>

    <p>
        Basically, the <code class="language-typescript">ngs-container</code> expects the two observables we mentionned,
        instantiates a <code class="language-typescript">ng-template</code> and passes the values emitted by <code
              class="language-typescript">data$</code> observable in its implicit variable. Here, we store these data
        in the variable <code class="language-typescript">pokemons</code> then we use it to display all the pokemons. We
        also display a small icon that sets the value of <code class="language-typescript">selectedId</code> on the
        pokemon id.
    </p>

    <p>
        One of the advantage of this component is that it handles loading and error states. Indeed, if the HTTP call
        fails, the container component catches it and can do something with the error. By default, it simply displays
        it. However, you can configure the container to display the error in a custom way. As for the loading
        indicator, the json server is configured to have a latency of one second and during this second, you can see
        that the <code class="language-typescript">ngs-container</code> displays "<em>Loading...</em>". There is
        different possibilities for the loading indicator format but here, we set the property <code
              class="language-typescript">loaderType</code> on <code class="language-typescript">text</code> to simply
        display a loading sentence. We'll see in the <a href="#ngs-container">ngs-container</a> chapter how to customize
        this loading indicator. Let's confirm all of this by running our application with the JSON server turned off:
    </p>

    <div class="img">
        <img src="assets/img/container-error.png" />
    </div>

    <p>
        The container correctly caught the error and displayed it. Now, let's start the JSON server and refresh our
        page.
        At first, we can see:
    </p>

    <div class="img">
        <img src="assets/img/container-loading-01.png" />
    </div>

    <p>
        Then after one second:
    </p>

    <div class="img">
        <img src="assets/img/container-loading-02.png" />
    </div>

    <p>
        So, as you can see, the <code class="language-typescript">ngs-container</code> really handles everything you
        need to fetch the data and display what needs to be displayed depending on the current state of the request.
    </p>

    <p>
        We'll go a little further by creating a component that will receive the id of a pokemon in input and display
        all its data. As we said earlier, the call we used in the main component only loaded some of the properties.
        Now, we'll see how to load all the properties of the pokemon with the specified id. First, let's add a method
        to our service in order to load a pokemon based on its id.
    </p>

    <pre>
<code class="language-typescript">public loadPokemonById(id: number): Observable&lt;Pokemon> {{ '{' }}
    return this._store.loadEntityByKey(`http://localhost:3000/pokemons-full/${{ '{' }}id}`, s => s.pokemons, id);
}
</code></pre>

    <p class="message information">
        This route fetches a pokemon based on its id and returns <strong>all its properties</strong>.
    </p>

    <p>
        <code class="language-typescript">loadEntityByKey</code> calls a route in order to load an entity if it is not
        yet in the store or if it is in the store but is flagged as not completely loaded, which is the case here.
        Indeed, we called <code class="language-typescript">loadAllEntities</code> by passing <code
              class="language-typescript">false</code> as the third parameter, indicating this way that loaded entities
        were not complete. Note that <code class="language-typescript">loadEntityByKey</code> also set the entity it
        loads as completely loaded (except if you pass <code class="language-typescript">false</code> in its fourth
        parameter), meaning that calling twice this function for the same entity will call the REST API
        only once. Moreover, and that's the case for all loading functions of "ng-store", if multiple components try to
        load an entity at the exact same time, only one call is made but the entity will be available for all
        components.
    </p>

    <p>
        Now that we have this function, we can use it in a new component:
    </p>

    <pre>
<code class="language-typescript">@Component({{ '{' }}
  selector: 'app-pokemon',
  templateUrl: './pokemon.component.html',
  changeDetection: ChangeDetectionStrategy.OnPush,
  standalone: true,
  imports: [
    JsonPipe,
    NgStoreModule
  ]
})
export class PokemonComponent {{ '{' }}

  @Input()
  public set id(value: number) {{ '{' }}
    this.query$ = this._pokemonService.loadPokemonById(value);
    this.pokemon$ = this._store.selectValueByKey(s => s.pokemons, value);
  }

  private readonly _pokemonService = inject(PokemonService);
  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public query$!: Observable&lt;Pokemon>;
  public pokemon$!: Observable&lt;Pokemon | null>;

}
</code></pre>

    <p>
        The idea here is the same than for the first component except that the <code
              class="language-typescript">query$</code> and <code class="language-typescript">data$</code> observables
        are defined in the setter of the id input. Now we can use them in the template:
    </p>

    <pre>
<code class="language-xml">&lt;ngs-container [query$]="query$"
    [data$]="pokemon$"
    loaderType="text">
    &lt;ng-template let-pokemon>
        &lt;pre>{{ '{' + '{' }} pokemon | json }}&lt;/pre>
    &lt;/ng-template>
&lt;/ngs-container>
</code></pre>

    <p>
        The only thing left to do is adding the following line in the template of the main component:
    </p>

    <pre>
<code class="language-xml">&lt;app-pokemon *ngIf="selectedId !== null"
             [id]="selectedId">&lt;/app-pokemon>
</code></pre>

    <p>
        And that's it. Let's have a look at the network tab of the console in order to see what happens in terms of HTTP
        calls. First, when the application starts:
    </p>

    <div class="img">
        <img src="assets/img/load-console-01.png" />
    </div>

    <p>
        Now, click on the eye icon of the first pokemon:
    </p>

    <div class="img">
        <img src="assets/img/load-console-02.png" />
    </div>

    <p>
        We see that the call to the route loading all the pokemon properties is correctly executed. Now, let's click on
        the eye of the second pokemon then click again on the eye of the first pokemon:
    </p>

    <div class="img">
        <img src="assets/img/load-console-03.png" />
    </div>

    <p>
        As you can see, the call for the second pokemon is correctly done, however, the call for the first pokemon is
        not done another time. Indeed, as the entity is in the store and is completely loaded, it does not get loaded
        once again. Note that you can force the query (to refresh data maybe) by passing <code
              class="language-typescript">true</code> as the fifth parameter.
    </p>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/06_Load"
           target="_blank">this example</a> of the playground.
    </p>

    <p>
        Let's spice things up a bit by checking how to load dependent data. Say that this time, our web services looks a
        bit more like what you would expect from a relational REST API. Meaning that instead of having the types of the
        pokemons as a string property, you have a route returning all the types and the property <code
              class="language-typescript">type</code> is replaced by the property <code
              class="language-typescript">typeId</code> which contains the id of the type.
    </p>

    <p>
        Moreover, we want to update our main component to display all the pokemon types and then, in another component,
        a list of all the pokemons of the selected type. Let's start by creating our models.
    </p>

    <p>
        The pokemon model:
    </p>

    <pre>
<code class="language-typescript">export type Pokemon = BaseEntity&lt;number> & {{ '{' }}
    name: string;
    typeId: number;
}
</code></pre>

    <p>
        And the type one:
    </p>

    <pre>
<code class="language-typescript">export type Type = BaseEntity&lt;number> & {{ '{' }}
    name: string;
}
</code></pre>

    <p>
        Now let's update our state:
    </p>

    <pre>
<code class="language-typescript">export type AppState = {{ '{' }}
    pokemons: Entities&lt;Pokemon>;
    types: Entities&lt;Type>;
}

export const initial: AppState = {{ '{' }}
    pokemons: createEntities&lt;Pokemon>([], ['typeId']),
    types: createEntities&lt;Type>()
}
</code></pre>

    <p>
        Now, it's time to update our service. The first function we'll implement is the one responsible of loading all
        the types in the store.
    </p>

    <pre>
<code class="language-typescript">public loadTypes(): Observable&lt;Type[]> {{ '{' }}
    return this._store.loadAllEntities('http://localhost:3000/types', s => s.types);
}
</code></pre>

    <p>
        Let's head to our main component to do the necessary changes to display all these types:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent {{ '{' }}

  private readonly _pokemonService = inject(PokemonService);
  private readonly _store: NgStore&ltAppState> = inject(NgStore);

  public selectedId: number | null = null;

  public query$: Observable&lt;Type[]> = this._pokemonService.loadTypes();
  public types$: Observable&lt;Type[]> = this._store.selectValues&lt;Type>(s => s.types).pipe(
    map(types => types.sort((t1, t2) => t1.name.localeCompare(t2.name)))
  );

  public trackByValue: TrackByFunction&lt;Pokemon> = trackByValue;

}
</code></pre>

    <pre>
<code class="language-xml">&lt;ngs-container [query$]="query$"
               [data$]="types$"
               loaderType="text">
    &lt;ng-template let-types>
        &lt;div class="flex-row flex-aic gap1"
             *ngFor="let t of types; trackBy: trackByValue">
            &lt;div>{{ '{' + '{' }} t.name }}&lt;/div>
            &lt;i class="fa fa-solid fa-eye pointer"
               (click)="selectedId = t.id">&lt;/i>
        &lt;/div>
    &lt;/ng-template>
&lt;/ngs-container>

&lt;app-pokemon-by-type *ngIf="selectedId !== null"
                     [id]="selectedId">&lt;/app-pokemon-by-type>
</code></pre>

    <p>
        Nothing much different so far. The only difference is that the component showing all the pokemons of the
        selected
        type is called <code class="language-typescript">app-pokemon-by-type</code> and that's in this component that
        we'll learn how to load dependent data. What I call dependant data are data that depends on another entity. In
        this case, we'll load the pokemon depending on their type. The first thing to do in order to load them easily
        with
        the store is to add a property to our "type" model:
    </p>

    <pre>
<code class="language-typescript">export type Type = BaseEntity&lt;number> & {{ '{' }}
    name: string;

    pokemonsLoaded: boolean;
}
</code></pre>

    <p>
        The property <code class="language-typescript">pokemonsLoaded</code> will be used by the store to determine
        whether the pokemons of that type have already been loaded or not and load them accordingly. Currently, this
        property is not optional and must be defined, so if you happen to insert data in the store manually, simply set
        it to <code class="language-typescript">false</code> and you'll be fine.
    </p>

    <p>
        Now, it's time to update our service to implement a function that will load pokemons from a specific type if
        they were not loaded yet.
    </p>

    <pre>
<code class="language-typescript">import {{ '{' }} findStoreValueByKey, NgStore } from "@ssougnez/ng-store";
    
public loadPokemonByType(id: number): Observable&lt;Pokemon[]> {{ '{' }}
    return this._store.loadEntities&lt;Pokemon, Type>(
        `http://localhost:3000/pokemons-with-type?typeId=${{ '{' }}id}`, 
        s => s.pokemons,
        findStoreValueByKey(s => s.types, id),
        'pokemonsLoaded',
        false
    );
}
</code></pre>

    <p>
        So basically, we use the <code class="language-typescript">loadEntities</code> function to load entities based
        on the property of another one. The two first parameters are the same than for the others functions, what's
        interesting is the third and fourth one. The third one allows you to find the depending entity. Most of the
        time, you'll use the utility function <code class="language-typescript">findStoreValueByKey</code> to do so.
        Simply pass it the section of the store where you want to find the depending entity and its id. Then, the fourth
        parameter is simply the name of the property to use in order to define whether the entities have been loaded or
        not. This has to be passed as a string to allow the store to update this property as he wishes to (which means
        that you should never update the value of this property by yourself). The last parameter is the same as for the
        others functions and determines whether entities are completely or partially loaded (in that case, they are only
        partially loaded).
    </p>

    <p>
        Now that we have this, we can implement the component showing the pokemons of a certain type:
    </p>

    <pre>
<code class="language-typescript">export class PokemonByTypeComponent {{ '{' }}

  @Input()
  public set id(value: number) {{ '{' }}
    this.query$ = this._pokemonService.loadPokemonByType(value);
    this.pokemons$ = this._store.selectValuesByIndex&lt;Pokemon>(s => s.pokemons, 'typeId', value);
  }

  private readonly _pokemonService = inject(PokemonService);
  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public trackByValue: TrackByFunction&lt;Pokemon> = trackByValue;

  public query$!: Observable&lt;Pokemon[]>;
  public pokemons$!: Observable&lt;Pokemon[]>;

}
</code></pre>

    <p>
        And the template:
    </p>

    <pre>
<code class="language-html">&lt;ngs-container [query$]="query$"
               [data$]="pokemons$"
               loaderType="text">
    &lt;ng-template let-pokemons>
        &lt;div *ngFor="let p of pokemons; trackBy: trackByValue">{{ '{' + '{' }} p.name }}&lt;/div>
    &lt;/ng-template>
&lt;/ngs-container>
</code></pre>

    <p>
        And that's it, folks! If you run your application, you'll have:
    </p>

    <div class="img">
        <img src="assets/img/dependent-01.png" />
    </div>

    <p>
        And when clicking on the eye next to a type:
    </p>

    <div class="img">
        <img src="assets/img/dependent-02.png" />
    </div>

    <p>
        Like for the other functions, it's important to note that:
    </p>

    <ul>
        <li>
            Entities are only loaded if they were not yet loaded. You can bypass this behavior by using the
            <code class="language-typescript">force</code> parameter.
        </li>
        <li>
            If multiple components try to load the same dependent data at the same moment, only one call is made.
        </li>
    </ul>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/07_Load_Dependent"
           target="_blank">this example</a> of the playground.
    </p>

    <p>
        There is one more function that you could use to load data in the store <code
              class="language-typescript">loadEntitiesOnce</code>. Basically, this function loads entities only once.
        The store uses the URL of the REST API to know whether the entities have already been loaded or not. This
        function is pretty straightforward so I won't show an example here but if you need it, you can still create an
        issue and I'll update the documentation.
    </p>

    <h1 id="post">Post</h1>

    <p>
        Now that we saw how to load data with the store, we are going to see how to create them. Let's start by creating
        the following models:
    </p>

    <pre>
<code class="language-typescript">export type PokemonType = 'water' | 'fire' | 'electric' | 'grass' | 'bug' | 'normal' | 'poison';

export type Pokemon = BaseEntity&lt;number> & {{ '{' }}
    name: string;
    type: PokemonType;
}

export type PokemonCreationData = {{ '{' }}
    name: string;
    type: PokemonType;
}
</code></pre>

    <p>
        We defined two types:
    </p>

    <ul>
        <li><strong>Pokemon</strong>: The type of our entities.</li>
        <li><strong>PokemonCreationData</strong>: Type of the data sent to the server to create a new pokemon.</li>
    </ul>

    <p>
        In the service, we'll have one function used to retrieve all the pokemons:
    </p>

    <pre>
<code class="language-typescript">export class PokemonService {{ '{' }}

    private _store: NgStore&ltAppState> = inject(NgStore);

    public loadPokemons(): Observable&ltPokemon[]> {{ '{' }}
        return this._store.loadAllEntities('http://localhost:3000/pokemons-full', s => s.pokemons);
    }

}
</code></pre>

    <p>
        Finally, the component simply displays all the pokemons:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent {{ '{' }}

  private readonly _pokemonService = inject(PokemonService);
  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public trackByValue: TrackByFunction&lt;Pokemon> = trackByValue;

  public query$: Observable&lt;Pokemon[]> = this._pokemonService.loadPokemons();
  public data$: Observable&lt;Pokemon[]> = this._store.selectValues&lt;Pokemon>(s => s.pokemons).pipe(
    map(pokemons => pokemons.sort((p1, p2) => p1.name.localeCompare(p2.name)))
  );

}
</code></pre>

    <pre>
<code class="language-xml">&lt;ngs-container [query$]="query$"
               [data$]="data$"
               loaderType="text">
    &lt;ng-template let-pokemons>
        &lt;div class="flex-row gap1">
            &lt;div class="flex-1">
                &lt;div *ngFor="let p of pokemons; trackBy: trackByValue">
                    {{ '{' + '{' }} p.name }}
                &lt;/div>
            &lt;/div>
            &lt;div class="flex-1">
                &lt;app-pokemon-add-form>&lt;/app-pokemon-add-form>
            &lt;/div>
        &lt;/div>
    &lt;/ng-template>
&lt;/ngs-container>
</code></pre>

    <p>
        So far, nothing new. However, we put a component called <code class="language-xml">app-pokemon-add-form</code>
        that we'll use to create new pokemons. Note that the goal is to automatically refresh the list of pokemons upon
        creation. Here is a first version of the code of this component:
    </p>

    <pre>
<code class="language-typescript">type FormData = {{ '{' }}
  name: FormControl&lt;string | null>;
  type: FormControl&lt;PokemonType | null>;
}

@Component({{ '{' }}
  selector: 'app-pokemon-add-form',
  templateUrl: './pokemon-add-form.component.html',
  changeDetection: ChangeDetectionStrategy.OnPush,
  standalone: true,
  imports: [
    AsyncPipe,
    ReactiveFormsModule
  ]
})
export class PokemonAddFormComponent implements OnInit {{ '{' }}

  private readonly _fb = inject(FormBuilder);
  private readonly _pokemonService = inject(PokemonService);
  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public form!: FormGroup&lt;FormData>;

  public ngOnInit(): void {{ '{' }}
    this.form = this._fb.group({{ '{' }}
      'name': new FormControl&lt;string | null>(null, Validators.required),
      'type': new FormControl&lt;PokemonType | null>(null, Validators.required),
    });
  }

  public add() {{ '{' }}

  }
}
</code></pre>

    <pre>
<code class="language-xml">&lt;form [formGroup]="form"
      (ngSubmit)="add()">
    &lt;div>
        &lt;label>
            Name: &lt;input type="text"
                   formControlName="name">
        &lt;/label>
    &lt;/div>
    &lt;div>
        &lt;label>
            Type: &lt;select formControlName="type">
                &lt;option value="water">Water&lt;/option>
                &lt;option value="fire">Fire&lt;/option>
                &lt;option value="electric">Electric&lt;/option>
                &lt;option value="grass">Grass&lt;/option>
                &lt;option value="bug">Bug&lt;/option>
                &lt;option value="normal">Normal&lt;/option>
                &lt;option value="poison">Poison&lt;/option>
            &lt;/select>
        &lt;/label>
    &lt;/div>
    &lt;button type="submit"
            [disabled]="form.valid === false">Create&lt;/button>
&lt;/form>
</code></pre>

    <p>
        Basically, we created a simple form using reactive forms and bound the submit event of the form to the <code
              class="language-typescript">add</code> function. Before implementing this function, we'll create the <code
              class="language-xml">addPokemon</code> function in the service that will use the store to perform the
        creation.
    </p>

    <pre>
<code class="language-typescript">public addPokemon(data: PokemonCreationData): Observable&lt;Pokemon> {{ '{' }}
    return this._store.postEntity&lt;Pokemon>('http://localhost:3000/pokemons-full', s => s.pokemons, data);
}
</code></pre>

    <p>
        Creating a new entity with the store is really easy, you just have to call the <code
              class="language-typescript">postEntity</code> function with the following parameters:
    </p>

    <ul>
        <li><strong>url</strong>: POST URL to call to create the entity.</li>
        <li><strong>root</strong>: Selector used to update the adding state of the entity list (more on that a bit
            later).</li>
        <li><strong>data</strong>: Payload sent to the server to create the entity.</li>
    </ul>

    <p>
        Now, it's just a matter of calling this function in our component:
    </p>

    <pre>
<code class="language-typescript">public add() {{ '{' }}
  const data: PokemonCreationData = {{ '{' }}
    name: this.form.value.name!,
    type: this.form.value.type!
  };

  this._pokemonService
    .addPokemon(data)
    .subscribe({{ '{' }}
      next: () => this.form.reset({{ '{' }} name: null, type: null }),
      error: err => console.log(err)
    })
}
</code></pre>

    <p>
        If you were to test the component, you'd notice that it works... ish... Two details are a bit annoying
        here:
    </p>

    <ul>
        <li>The pokemon gets created but a refresh is required to actually see it.</li>
        <li>The button is enabled during the REST call, meaning that a user could potentially clicks multiple times on
            the button and therefore create the pokemon more than once.</li>
    </ul>

    <p>
        The first point is really easy to solve with the store. You just need to update the function in the service like
        so:
    </p>

    <pre>
<code class="language-typescript">public addPokemon(data: PokemonCreationData): Observable&lt;Pokemon> {{ '{' }}
    return this._store
        .postEntity&lt;Pokemon>('http://localhost:3000/pokemons-full', s => s.pokemons, data)
        .pipe(
            tap(pokemon => this._store.upsertValue(s => s.pokemons, pokemon))
        );
}
</code></pre>

    <p>
        Basically, we just piped the observable returned by the function to add the value emitted in the "pokemons"
        section
        of the store. Of course, this will only work if, like JSON server, your REST API returns the created entity. If
        not, you'll have to find another way to refresh your store. Here are some ideas:
    </p>

    <ul>
        <li>
            If you web service does not return any interesting value (which it shouldn't), pipe the call to <code
                  class="language-typescript">postEntity</code> with a <code
                  class="language-typescript">switchMap</code> to <code
                  class="language-typescript">loadAllEntities</code> with the <code
                  class="language-typescript">force</code> flag to <code class="language-typescript">true</code>.
        </li>
        <li>
            If your web service only returns the id of the created entity, pipe the call to <code
                  class="language-typescript">postEntity</code> with a <code
                  class="language-typescript">switchMap</code> to <code
                  class="language-typescript">loadEntityByKey</code> with this id.
        </li>
        <li>
            If, like me, you love using web socket connections, call <code
                  class="language-typescript">upsertValue</code> in the callback function handling the creation of a
            pokemon.
        </li>
    </ul>

    <p>
        So if you try your component now, you'll notice that the list of pokemons get refresh automatically. However,
        the button is still enabled during the call. One way to fix this would be to do this:
    </p>

    <pre>
<code class="language-typescript">public adding = false;

public add() {{ '{' }}
  this.adding = true;

  const data: PokemonCreationData = {{ '{' }}
    name: this.form.value.name!,
    type: this.form.value.type!
  };

  this._pokemonService
    .addPokemon(data)
    .pipe(finalize(() => this.adding = false))
    .subscribe({{ '{' }}
      next: () => this.form.reset({{ '{' }} name: null, type: null }),
      error: err => console.log(err)
    })
}
</code></pre>

    <pre>
<code class="language-xml">&lt;button type="submit"
        [disabled]="form.valid === false || adding === true">Create&lt;/button>
</code></pre>

    <p>
        This would work perfectly fine, however, it's a little verbose, especially if you have to do this every time you
        create a component creating data. A good alternative consists in relying on the store. Indeed, when using <code
              class="language-typescript">postEntity</code>, the store automatically maintains the "adding" state of the
        store section you're using. In other words, you can achieve the same like this:
    </p>

    <pre>
<code class="language-typescript">public adding$: Observable&lt;boolean> = this._store.select(s => s.pokemons).pipe(map(e => e.adding));

public add() {{ '{' }}
  const data: PokemonCreationData = {{ '{' }}
    name: this.form.value.name!,
    type: this.form.value.type!
  };

  this._pokemonService
    .addPokemon(data)
    .subscribe({{ '{' }}
      next: () => this.form.reset({{ '{' }} name: null, type: null }),
      error: err => console.log(err)
    })
}
</code></pre>

    <p>
        And now, you can use this obervable in the template:
    </p>

    <pre>
<code class="language-xml">&lt;button type="submit"
        [disabled]="form.valid === false || (adding$ | async) === true">Create&lt;/button>
</code></pre>

    <p>
        At the end, you only save two lines of code but on the long run, this feature comes very handy.
    </p>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/08_Post"
           target="_blank">this example</a> of the playground.
    </p>

    <h1 id="put">Put</h1>

    <p>
        To demonstrate how to update data with the store, we'll start with the code of <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/08_Post">the previous
            example</a>. First, we need to change the model containing updated data:
    </p>

    <pre>
<code class="language-typescript">export type PokemonUpsertData = {{ '{' }}
    id: number | null;
    name: string;
    type: PokemonType;
}
</code></pre>

    <p>
        the <code class="language-typescript">id</code> property is a number or <code
              class="language-typescript">null</code> as it can contain both values; a
        number when you want to update an existing entity or <code class="language-typescript">null</code> when you want
        to create it. As for the service:
    </p>

    <pre>
<code class="language-typescript">export class PokemonService {{ '{' }}

    private _store: NgStore&lt;AppState> = inject(NgStore);

    public loadPokemons(): Observable&lt;Pokemon[]> {{ '{' }}
        return this._store.loadAllEntities('http://localhost:3000/pokemons-full', s => s.pokemons);
    }

    public loadPokemonById(id: number): Observable&lt;Pokemon> {{ '{' }}
        return this._store.loadEntityByKey(`http://localhost:3000/pokemons-full/${{ '{' }}id}`, s => s.pokemons, id);
    }

}
</code></pre>

    <p>
        Now, let's update the main component in order to display an edit icon next to the names of the pokemons:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent {{ '{' }}

  private readonly _pokemonService = inject(PokemonService);
  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public selectedId: number | null = null;
  public trackByValue: TrackByFunction&lt;Pokemon> = trackByValue;

  public query$: Observable&lt;Pokemon[]> = this._pokemonService.loadPokemons();
  public data$: Observable&lt;Pokemon[]> = this._store.selectValues&lt;Pokemon>(s => s.pokemons).pipe(
    map(pokemons => pokemons.sort((p1, p2) => p1.name.localeCompare(p2.name)))
  );

}
</code></pre>

    <pre>
<code class="language-xml">&lt;ngs-container [query$]="query$"
               [data$]="data$"
               loaderType="text">
    &lt;ng-template let-pokemons>
        &lt;div class="flex-row gap1">
            &lt;div class="flex-1">
                &lt;div class="flex-row flex-aic gap1"
                     *ngFor="let p of pokemons; trackBy: trackByValue">
                    &lt;div>{{ '{' + '{' }} p.name }}&lt;/div>
                    &lt;i class="fa fa-solid fa-edit pointer"
                       (click)="selectedId = selectedId === p.id ? null : p.id">&lt;/i>
                &lt;/div>
            &lt;/div>
            &lt;div class="flex-1">
                &lt;app-pokemon-upsert-form [id]="selectedId">&lt;/app-pokemon-upsert-form>
            &lt;/div>
        &lt;/div>
    &lt;/ng-template>
&lt;/ngs-container>
</code></pre>

    <p>
        Here, the only subtility is on the click event of the icon. Basically, it changes the <code
              class="language-typescript">selectedId</code> variable on the id of the pokemon to edit or <code
              class="language-typescript">null</code> if <code class="language-typescript">selectedId</code> already
        contains it. It allows to select the pokemon if it was not yet selected or unselect it otherwise.
    </p>

    <p>
        The most important code is located in the upsert component:
    </p>

    <pre>
<code class="language-typescript">type FormData = {{ '{' }}
  id: FormControl&lt;number | null>;
  name: FormControl&lt;string | null>;
  type: FormControl&lt;PokemonType | null>;
}

export class PokemonUpsertFormComponent implements OnInit {{ '{' }}

  @Input()
  public set id(value: number | null) {{ '{' }}
    this.query$ = value === null ? of(null) : this._pokemonService.loadPokemonById(value);
    this.data$ = value === null ? of(null) : this._store.selectValueByKey(s => s.pokemons, value).pipe(filter(e => e !== null), take(1));
  }

  private readonly _fb = inject(FormBuilder);
  private readonly _pokemonService = inject(PokemonService);
  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public form!: FormGroup&lt;FormData>;

  public busy$: Observable&lt;boolean> = this._store.select(s => s.pokemons).pipe(map(e => e.busy));
  public data$!: Observable&lt;Pokemon | null>;
  public query$!: Observable&lt;Pokemon | null>;

  public ngOnInit(): void {{ '{' }}
    this.form = this._fb.group({{ '{' }}
      'id': new FormControl&lt;number | null>(null),
      'name': new FormControl&lt;string | null>(null, Validators.required),
      'type': new FormControl&lt;PokemonType | null>(null, Validators.required),
    });
  }

  public upsert() {{ '{' }}
    const data: PokemonUpsertData = {{ '{' }}
      id: this.form.value.id!,
      name: this.form.value.name!,
      type: this.form.value.type!
    };

    this._pokemonService
      .upsertPokemon(data)
      .subscribe({{ '{' }}
        next: () => this.form.value.id === null && this.reset(null),
        error: err => console.log(err)
      })
  }

  public reset(pokemon: Pokemon | null) {{ '{' }}
    this.form.reset({{ '{' }}
      id: pokemon?.id || null,
      name: pokemon?.name || null,
      type: pokemon?.type || null
    })
  }

}
</code></pre>

    <p>
        So the idea here is that we won't assume that the entity you want to update is already in the store. In a real
        life scenario, it is most likely that entities will be loaded prior being able to update them but let's imagine
        it's not the case.
    </p>

    <p>
        The <code class="language-typescript">id</code> input can recieve two different values:
    </p>

    <ul>
        <li><strong>null</strong>: Means that we want to create a new pokemon.</li>
        <li><strong>A number</strong>: Means that we want to update the pokemon with this id.</li>
    </ul>

    <p>
        So, depending on the value of this input, we will either set the <code class="language-typescript">query$</code>
        and <code class="language-typescript">data$</code> observables on an observable emitting the <code
              class="language-typescript">null</code> value (in case of creation) or on observables used to load and
        select
        the entity. Note that we use the operators <code class="language-typescript">filter</code> and <code
              class="language-typescript">take</code> in order to only used the first non null emitted value. We do that
        for a specific reason. Indeed, we'll set the value of the form based on the current data of the entity. However,
        if we didn't stop after the first non null emitted value, we would have taken the risk to lost our modification
        during the edition. Indeed, say you fetched the pokemon 1 and set the value of the form based on it. Now, while
        you're typing the new name of the pokemon, the state of the entity changes (maybe in reaction to a web socket
        message). As a new value is emitted, the form will reset with the new values and you'll lose all your
        modifications. This is why we used <code class="language-typescript">take</code>; in
        order to avoid losing the current modification.
    </p>

    <p>
        Then we have the <code class="language-typescript">busy$</code> observable. In order to disable the button, we
        could check the "adding" state of the entity list or the "updating" state of the entity but there is an easier
        solution. Indeed, whenever an entity is being added, deleted or updated, the "busy" state of the entity list is
        set to <code class="language-typescript">true</code>. So in this case, we can simply used this state to know
        whether an entity is being updated or added.
    </p>

    <p>
        In the <code class="language-typescript">ngOnInit</code>, we simply create our form with default values.
    </p>

    <p>
        In the <code class="language-typescript">upsert</code> function, we simply create the payload then send it to
        the <code class="language-typescript">upsertPokemon</code> function. Note that we only reset the form value in
        case of creation. Indeed, in case of update, we want to keep the data synchronized with the <code
              class="language-typescript">id</code> property.
    </p>

    <p>
        The <code class="language-typescript">reset</code> function resets the form based on the object received in
        parameter.
    </p>

    <p>
        Now let's have a look at the template:
    </p>

    <pre>
<code class="language-xml">&lt;ngs-container [query$]="query$"
               [data$]="data$"
               (changed)="reset($event)">
    &lt;ng-template let-pokemon>
        &lt;form [formGroup]="form"
              (ngSubmit)="upsert()">
            &lt;div>
                &lt;label>
                    Name: &lt;input type="text"
                           formControlName="name">
                &lt;/label>
            &lt;/div>
            &lt;div>
                &lt;label>
                    Type: &lt;select formControlName="type">
                        &lt;option value="water">Water&lt;/option>
                        &lt;option value="fire">Fire&lt;/option>
                        &lt;option value="electric">Electric&lt;/option>
                        &lt;option value="grass">Grass&lt;/option>
                        &lt;option value="bug">Bug&lt;/option>
                        &lt;option value="normal">Normal&lt;/option>
                        &lt;option value="poison">Poison&lt;/option>
                    &lt;/select>
                &lt;/label>
            &lt;/div>
            &lt;button type="submit"
                    [disabled]="form.valid === false || (busy$ | async) === true">
                {{ '{' + '{' }} form.value.id === null ? 'Create' : 'Update' }}
            &lt;/button>
        &lt;/form>
    &lt;/ng-template>
&lt;/ngs-container>
</code></pre>

    <p>
        We're using the <code class="language-typescript">changed</code> event of the container to execute a function
        when the data emitted by <code class="language-typescript">data$</code> changes. In this case, we want to reset
        the form with the emitted value. Remember, in case of <code class="language-typescript">id null</code>, we
        emit the value <code class="language-typescript">null</code>, however, if the <code
              class="language-typescript">id</code> is defined, we emit to first non-null value from the store.
    </p>

    <p>
        The last thing to note is the button: we disable it if the form is invalid or if the <code
              class="language-typescript">busy$</code> observable emits <code class="language-typescript">true</code>.
        Moreover, we change the label of the button depending on the <code class="language-typescript">id</code> field
        of the form.
    </p>

    <p>
        Note that we could have done this in different ways, but it's important to use an observable for the busy state
        of the form. Indeed, as we are using the <code class="language-typescript">OnPush</code> change detection
        strategy, it's important to refresh the view when the state of the form changes. Without this, we would have
        needed to <code class="language-typescript">markForCheck</code> the component in order to reflect the form
        reset after the update was done.
    </p>

    <p>
        The last piece of the puzzle is the <code class="language-typescript">upsertPokemon</code> function of the
        service:
    </p>

    <pre>
<code class="language-typescript">public upsertPokemon(data: PokemonUpsertData): Observable&lt;Pokemon> {{ '{' }}
    const action$ = data.id === null
        ? this._store.postEntity(`http://localhost:3000/pokemons-full`, s => s.pokemons, data)
        : this._store.putEntityByKey&lt;Pokemon>(`http://localhost:3000/pokemons-full/${{ '{' }}data.id}`, s => s.pokemons, data.id, data);

    return action$.pipe(
        tap(pokemon => this._store.upsertValue(s => s.pokemons, pokemon))
    );
}
</code></pre>

    <p>
        This function is actually a bit more complicated than it needs to be "because" of the JSON server. Indeed, in
        real life scenario, you would probably have implemnted an upsert function creating or updating the entity.
        However,
        JSON server does not provide a route to do both. You either have to perform a POST to create the entity of a PUT
        to update it.
    </p>

    <p>
        However, it is not very complicated. Basically, if <code class="language-typescript">data.id</code> is <code
              class="language-typescript">null</code>, we call the <code class="language-typescript">postEntity</code>
        function like we did in the previous example. Otherwise, we call <code
              class="language-typescript">putEntityByKey</code> that behaves exactly like <code
              class="language-typescript">postEntity</code> but requires the key of the entity as the third parameter.
        As both functions return the same type of object, you can store it in a single variable then pipe it in order to
        update the store once the call is done.
    </p>

    <p>
        And that's it, you have a component that can add or update an entity pretty easily.
    </p>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/09_Put"
           target="_blank">this example</a> of the playground.
    </p>

    <h1 id="delete">Delete</h1>

    <p>
        The last operation left to support is the deletion of values in the store. Here are the relevant parts of the
        example:
    </p>

    <p>
        First, the model:
    </p>

    <pre>
<code class="language-typescript">export type Pokemon = BaseEntity&lt;number> & {{ '{' }}
    name: string;
    type: 'water' | 'fire' | 'electric' | 'grass' | 'bug' | 'normal' | 'poison';
}
</code></pre>

    <p>
        Then, the service:
    </p>

    <pre>
<code class="language-typescript">export class PokemonService {{ '{' }}

    private _store: NgStore&lt;AppState> = inject(NgStore);

    public deletePokemon(id: number): Observable&lt;Pokemon> {{ '{' }}
        return this._store.deleteEntityByKey(`http://localhost:3000/pokemons-full/${{ '{' }}id}`, s => s.pokemons, id).pipe(
            tap(pokemon => this._store.removeValuesByKeys(s => s.pokemons, id))
        );
    }

    public loadPokemons(): Observable&lt;Pokemon[]> {{ '{' }}
        return this._store.loadAllEntities('http://localhost:3000/pokemons-full', s => s.pokemons);
    }

}
</code></pre>

    <p>
        Deleting an item from the store using a REST call can be done using the <code
              class="language-typescript">deleteEntityByKey</code> function. It simply expects the route to the REST
        API, the section of the store to find the entity and its key. Note that this function only calls the route and
        set the <code class="language-typescript">deleting</code> property of the entity to <code
              class="language-typescript">true</code> but does not actually remove the entity from the store, which is
        why we pipe the observable to a call to the <code class="language-typescript">removeValuesByKeys</code> function
        that actually removes the entity from the store. Note that you can pass more than one key if you wish to delete
        multiple entities.
    </p>

    <p>
        There is also another function called <code class="language-typescript">removeValuesBy</code> that can be used
        to remove entities based on a predicate.
    </p>

    <p>
        Now, the code of the main component:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent {{ '{' }}

  private readonly _pokemonService = inject(PokemonService);
  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public query$: Observable&lt;Pokemon[]> = this._pokemonService.loadPokemons();
  public pokemons$: Observable&lt;Entity&lt;Pokemon>[]> = this._store.selectEntities&lt;Pokemon>(s => s.pokemons).pipe(
    map(pokemons => pokemons.sort((p1, p2) => p1.value.name.localeCompare(p2.value.name)))
  );

  public trackByEntity: TrackByFunction&lt;Entity&lt;Pokemon>> = trackByEntity;

  public deletePokemon(id: number) {{ '{' }}
    this._pokemonService
      .deletePokemon(id)
      .subscribe({{ '{' }}
        error: err => console.log(err)
      })
  }
}
</code></pre>

    <p>
        The code is pretty self explanatory but there is one thing worth noticing. So far, we only selected values from
        the store because we didn't need to access their state (adding, updating or deleting). Here, we want to display
        a deleting indicator while the entity is being deleted. To do so, we'll select the pokemon as entities instead
        of as values. This also means that we need to use <code class="language-typescript">trackByEntity</code> instead
        of <code class="language-typescript">trackByValue</code>.
    </p>

    <p>
        And finally the template:
    </p>

    <pre>
<code class="language-xml">&lt;ngs-container [query$]="query$"
               [data$]="pokemons$"
               loaderType="text">
    &lt;ng-template let-pokemons>
        &lt;div class="flex-row flex-aic gap1"
             *ngFor="let p of pokemons; trackBy: trackByEntity">
            &lt;div>{{ '{' + '{' }} p.value.name }}&lt;/div>
            &lt;i class="fa fa-solid fa-trash pointer"
               (click)="deletePokemon(p.value.id)"
               *ngIf="p.deleting === false">&lt;/i>
            &lt;i class="fa fa-spin fa-spinner"
               *ngIf="p.deleting === true">&lt;/i>
        &lt;/div>
    &lt;/ng-template>
&lt;/ngs-container>
</code></pre>

    <p>
        Note that here, we use the <code class="language-typescript">value</code> property of the entities to access the
        actual <code class="language-typescript">Pokemon</code> object. However, we use the property <code
              class="language-typescript">deleting</code> to define whether the displayed icon is the little trash or
        the spinner. This works because the <code class="language-typescript">deleteEntityByKey</code> function updates
        the <code class="language-typescript">deleting</code> property of the entity during deletion, so you don't have
        to handle this yourself.
    </p>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/10_Delete"
           target="_blank">this example</a> of the playground.
    </p>

    <h1 id="ngs-container">ngs-container</h1>

    <p>
        Coming soon...
    </p>

    <h1 id="store-component">store-component</h1>

    <p>
        Coming soon...
    </p>

    <h1 id="roadmap">Roadmap</h1>

    <p>
        Here you'll find the next features I'd like to add to this library. Don't hesitate to post an issue to propose
        some ideas ðŸ˜‰
    </p>

    <ul>
        <li>Support for standalone components</li>
        <li>Unit testing</li>
    </ul>

</main>

<app-top-cta></app-top-cta>