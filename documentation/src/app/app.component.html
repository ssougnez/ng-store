<main>
    <div class="logo">

        <div class="title">
            <span>ng-st</span>
            <img src="assets/img/logo.svg"
                 alt="Logo" />
            <span>re</span>
        </div>
    </div>

    <h1>Table of content</h1>

    <ul>
        <li><a href="#context">Context</a></li>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#playground">Playground</a></li>
        <li><a href="#installation">Installation</a></li>
        <li><a href="#principle">Principle</a></li>
        <li><a href="#models">Models</a></li>
        <li><a href="#state">State</a></li>
        <li><a href="#configuration">Configuration</a></li>
        <li><a href="#find">Find</a></li>
        <li><a href="#select">Select</a></li>
        <li><a href="#indexes">Indexes</a></li>
        <li><a href="#upsert">Update</a></li>
        <li><a href="#remove">Remove</a></li>
        <li><a href="#load">Load</a></li>
        <li><a href="#post">Post</a></li>
        <li><a href="#put">Put</a></li>
        <li><a href="#delete">Delete</a></li>
        <li><a href="#ngs-container">ngs-container</a></li>
        <li><a href="#store-component">StoreComponent</a></li>
        <li><a href="#roadmap">Roadmap</a></li>
    </ul>

    <h1 id="context">Context</h1>

    <p>
        Effective data management is crucial for the success of an Angular application as it can significantly influence
        the development process. "ng-store" is a tool that helps to manage data in a store similar to a relational
        database, providing a simple and organized solution for data management within an Angular application.
    </p>

    <h1 id="introduction">Introduction</h1>

    <p>
        As you embark on your journey to learn Angular, you will encounter numerous concepts and challenges that you
        must overcome. It is common for beginners to overlook the importance of effective data management amidst the
        abundance of information they are trying to absorb. However, data management is a crucial aspect of Angular
        development that should not be neglected.
    </p>

    <p>
        When starting out with Angular, it may be tempting to create large, complex components to power your
        application. Initially, it may seem simpler to have all the necessary functionality in a single component.
        However, over time, it becomes clear that this approach can cause more problems than it solves, leading to a
        less maintainable and scalable application.
    </p>

    <p>
        As you progress in your Angular learning journey, you will eventually face the challenge of managing data in the
        most effective manner. At first, it is common to store data within a component, using the <code
              class="language-typescript">HttpClient</code> service to fetch data and display it on the screen. However,
        as you gain more experience, you will discover more advanced techniques for managing data in a more organized
        and scalable way.
    </p>

    <p>While this method of data management can be effective, there are some drawbacks to consider.</p>

    <ul>
        <li>
            In a well-designed application, components should have a single, specific purpose. Fetching data using a
            HTTP call and displaying it involves two separate functions, which would not be considered best practice in
            component design.
        </li>
        <li>
            Data that is loaded within a component is only accessible within that specific component.
        </li>
        <li>
            The number of class variables required to store the data may vary depending on the complexity of the
            component.
        </li>
        <li>
            If multiple components require the same data, it will need to be retrieved multiple times, potentially
            leading to reduced performance.
        </li>
    </ul>

    <p>One solution to these issues is to use services to store data. This approach has several advantages.</p>

    <ul>
        <li>
            Centralized data: When data is loaded through a service, it can be accessed by multiple components.
        </li>
        <li>
            Improved efficiency: The service handles the process of retrieving the data, allowing components to access
            it simply by injecting the service and using the stored data.
        </li>
    </ul>

    <p>
        While using services for data management can be a useful technique, it is not without its challenges. Some
        potential drawbacks include:
    </p>

    <ul>
        <li>
            Cyclic dependencies can occur when service A depends on data from service B, and vice versa. This can create
            a difficult-to-resolve circular dependency.
        </li>
        <li>
            Maintaining consistent data management practices across services can be challenging. While a base class can
            help to enforce a standardized approach, it can also add complexity to the codebase.
        </li>
        <li>
            If you are using the "OnPush" change detection strategy (as is recommended for optimal performance), simply
            updating data in a service will not trigger a refresh of the views that depend on it. To propagate the data
            changes to the components, you will need to implement a system that explicitly communicates the value
            changes. While this is not overly complex, it does add unnecessary boilerplate code.
        </li>
        <li>
            You will still need to consider and implement a consistent approach for fetching data from the back end.
        </li>
    </ul>

    <p>
        I encountered these issues and considerations regularly in my work, which motivated me to explore the various
        store/state management systems available.
    </p>

    <p>
        To be honest, I only evaluated one store/state management system: <a href="https://ngrx.io/"
           target="_blank">ngrx</a>. This was primarily because it is the most widely used and well-known option.
    </p>

    <p>
        Please note that my experience with ngrx is limited, and the following information may not be comprehensive or
        entirely accurate as I have not used it extensively. It is also possible that some of the details may have
        changed since my last usage.
    </p>

    <p>
        Overall, my impression of this library is that it is excessively complex to use. You are required to create
        actions, effects, reducers, selectors, etc., and while everything ultimately fits together, it can be difficult
        to maintain a clear understanding of what is happening in your application or to debug it effectively. The sheer
        number of required components can make the codebase cumbersome to navigate.
    </p>

    <p>
        I also struggled with the way immutability is managed in ngrx. To create new objects based on existing ones, you
        must manually use the spread operator, which I found to be cumbersome and not very intuitive. "ng-store" handles
        this differently, making the process transparent to the user.
    </p>

    <p>
        While ngrx may be a suitable solution for some, it did not meet my needs and expectations. It is worth noting
        that this is a personal opinion and that the library may be well-suited for others.
    </p>

    <p>
        Despite my issues with ngrx, I appreciated the concept of having a central location to store all application
        data and the reactivity of the store. As a result, I decided to create my own store management library to
        address these needs.
    </p>

    <p>
        As of 2023, I have been using and developing this library for two years, and it has now reached a stable state.
        I believe it may be useful for other developers, and that is why I am sharing it.
    </p>

    <p>
        This documentation will cover the fundamental principles of ng-store, as well as how to set it up and use it. By
        the end of this guide, you should have a thorough understanding of the library and, if you find it appealing, be
        equipped to use it in your own application. ðŸ˜€
    </p>

    <h1 id="playground">Playground</h1>

    <p>
        You can access the code for the examples discussed in this article on the <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src"
           target="_blank">GitHub playground</a>. To switch between examples, simply update the line 6 of the "main.ts"
        file. All the necessary code is provided for you to build and run the examples.
    </p>

    <h1 id="installation">Installation</h1>

    <p>Simply run:</p>

    <pre><code class="language-typescript">yarn add immer @ssougnez/ng-store</code></pre>

    <h1 id="principle">Principle</h1>

    <p>
        While you are free to use "ng-store" in any way that suits your needs, this section provides some
        recommendations for optimal usage.
    </p>

    <p>
        The main principle of "ng-store" is to use "flat objects" as much as possible. By "flat objects," I refer to
        objects that do not have any complex properties aside from those containing abstract data. For example, the
        following is not a "flat object":
    </p>

    <pre>
<code class="language-typescript">{{ '{' }}
    firstName: "Nicolas",
    lastName: "Cage",
    age: 50,
    friends: [{{ '{' }}
        firstName: "Nicole",
        lastName: "Kidman",
        age: 56
    }]
}</code></pre>

    <p>
        Using this type of object can lead to data redundancy. For instance, if these data are retrieved from a back end
        using a REST API, it is likely that multiple users will have the same friends. This means that a user's data
        might be stored in the "friends" array of multiple objects, resulting in larger, duplicated data. A better
        approach would be:
    </p>

    <pre>
<code class="language-typescript">{{ '{' }}
    firstName: "Nicolas",
    lastName: "Cage",
    age: 50,
    friends: [3, 19, 5]
}</code></pre>

    <p>
        This approach treats objects as <strong>entities</strong>, identified by a specific property and containing only
        abstract data as complex properties. "Abstract data" refers to information that does not represent entities in
        and of themselves, such as configuration data for a specific entity.
    </p>

    <p>
        Think of entities as rows in a relational database. These rows contain simple data in regular columns, and when
        more complex data is needed, it is stored in another table and referenced by a foreign key in the primary table.
        In some cases, it may also be useful to store abstract data as a JSON string in a text column.
    </p>

    <p>
        Adhering to this principle will greatly aid in your use of "ng-store" and also in designing your back end. When
        there are no clear guidelines for the structure of objects returned by a web service, it can be challenging to
        determine which data to fetch from the database, as it is not clear which data will be needed by the REST API
        call. With this approach, you will typically fetch data from the database in the most straightforward manner.
    </p>

    <h1 id="models">Models</h1>

    <p>
        The central concept of the store is "entities." As mentioned earlier, an entity is a basic object with only
        simple properties, and it must also have an "id" property of a specific type. To ensure that this requirement is
        met, all your entities must extend the <code class="language-typescript">BaseEntity&lt;T></code> base class,
        where "T" is the type of the "id" property. For example, the following is a "PokÃ©mon" entity:
    </p>

    <pre>
<code class="language-typescript">import {{ '{' }} BaseEntity } from "@ssougnez/ng-store";

export type Pokemon = BaseEntity&lt;number> & {{ '{' }}
    name: string;
    type: 'water' | 'fire' | 'electric' | 'grass' | 'bug' | 'normal' | 'poison';
}</code></pre>

    <p>
        It is important to note that these entities are not stored as-is in the store. In the example above, a value of
        type "Pokemon" will be stored as an <code class="language-typescript">Entity&lt;Pokemon></code> object. This
        type allows ng-store to efficiently store and retrieve values. For now, the most important thing to remember is
        that
        an object of type <code class="language-typescript">Entity&lt;T></code> has a <code
              class="language-typescript">value</code> property that holds the actual <code
              class="language-typescript">Pokemon</code> object. The type <code
              class="language-typescript">Entity&lt;T></code> also has other properties that will be discussed later in
        this document.
    </p>

    <p>
        For the remainder of this article, the following terms will be used:
    </p>

    <ul>
        <li><strong>Value:</strong> A value is the object you want to store, such as a "Pokemon" object.</li>
        <li><strong>Entity:</strong> An entity is a value wrapped in a <code
                  class="language-typescript">Entity&lt;T></code> object.</li>
    </ul>

    <h1 id="state">State</h1>

    <p>
        Now that we have an entity, we can create our state. A state consists of a type that defines its shape and an
        initial value. First, let's define the shape of the state. In this example, it will contain a section called
        "pokemons." A section can be thought of as a table in a database, storing data of the same type.
    </p>

    <p>
        I usually create the state in a file called "app.state" located in a "states" directory.
    </p>

    <pre>
<code class="language-typescript">import {{ '{' }} Pokemon } from "../models/pokemon.model";

export type AppState = {{ '{' }}
    pokemons: Entities&lt;Pokemon>;
}</code></pre>

    <p>
        In addition to defining the shape of the state, we also need to define its initial value. In the same file, add
        the following lines:
    </p>

    <pre>
<code class="language-typescript">import {{ '{' }} createEntities, Entities } from "@ssougnez/ng-store";
    
    export const initial: AppState = {{ '{' }}
        pokemons: createEntities()
    }</code></pre>

    <p>
        The <code class="language-typescript">createEntities</code> function creates an empty section in your store.
    </p>

    <h1 id="configuration">Configuration</h1>

    <p>
        The final step is to configure your application to use the store with its initial value. Here is how to do this
        using the modules approach:
    </p>

    <pre>
<code class="language-typescript">@NgModule({{ '{' }}
    imports: [
      NgStoreModule
    ],
    providers: [
      {{ '{' }}
        provide: NG_STORE_CONFIG,
        useValue: {{ '{' }}
          initialValue: initial,
          httpClientType: null
        } as StoreConfiguration
      }
    ]
  })
  export class AppModule {{ '{' }} }
</code></pre>

    <p>
        Alternatively, if you are using a standalone application:
    </p>

    <pre>
<code class="language-typescript">provideStore({{ '{' }}
    initialValue: initial,
    httpClientType: null
})
</code></pre>

    <p>
        The configuration object also accepts other properties, which will be covered later in this documentation.
    </p>

    <p>
        ng-store supports loading data asynchronously using HTTP requests. To use this feature, you can either omit the
        <code class="language-typescript">httpClientType</code> to use the default HTTP client provided by Angular or
        specify a custom class for it (more on this later).
    </p>

    <h1 id="find">Find functions</h1>

    <p>
        Find functions are used to locate entities or values in the store. Let's start by updating the initial state of
        the store to insert some data.
    </p>

    <pre>
<code class="language-typescript">export const initial: AppState = {{ '{' }}
    pokemons: createEntities&lt;Pokemon>([
        {{ '{' }}
            id: 1,
            name: 'Pikachu',
            type: 'electric'
        },
        {{ '{' }}
            id: 2,
            name: 'Bulbasaur',
            type: 'grass'
        },
        {{ '{' }}
            id: 3,
            name: 'Charmander',
            type: 'fire'
        },
        {{ '{' }}
            id: 4,
            name: 'Charmander',
            type: 'fire'
        },
        {{ '{' }}
            id: 5,
            name: 'Squirtle',
            type: 'water'
        },
        {{ '{' }}
            id: 6,
            name: 'Caterpie',
            type: 'bug'
        },
        {{ '{' }}
            id: 7,
            name: 'Weedle',
            type: 'bug'
        },
        {{ '{' }}
            id: 8,
            name: 'Pidgey',
            type: 'normal'
        },
        {{ '{' }}
            id: 9,
            name: 'Nidoran',
            type: 'normal'
        },
        {{ '{' }}
            id: 10,
            name: 'Rattata',
            type: 'normal'
        },
        {{ '{' }}
            id: 11,
            name: 'Spearow ',
            type: 'normal'
        },
        {{ '{' }}
            id: 12,
            name: 'Ekans ',
            type: 'poison'
        }
    ])
}</code></pre>

    <p>
        This is the code necessary to retrieve all the pokemons from the store:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent {{ '{' }}

  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public pokemons: Pokemon[] = this._store.getValues(s => s.pokemons);
  public trackByValue: TrackByFunction&lt;Pokemon> = trackByValue;

}</code></pre>

    <p>
        We use the <code class="language-typescript">getValues</code> function to return all the values stored in the
        "pokemons" section of the store. The <code class="language-typescript">trackByValue</code> variable is a
        function provided by ng-store that tells <code class="language-typescript">ngFor</code> to use the "id" property
        of array values.
    </p>

    <pre>
<code class="language-xml">&lt;h1>Pokemon&lt;/h1>

&lt;div *ngFor="let pokemon of pokemons; trackBy: trackByValue">{{ '{' + '{' }} pokemon.name }}&lt;/div></code></pre>

    <p>The result being:</p>

    <div class="img">
        <img src="assets/img/get-values.png" />
    </div>

    <p>
        To understand the difference between an entity and its value, let's use this variation of the code:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent {{ '{' }}

  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public pokemons: Entity&lt;Pokemon>[] = this._store.getEntities(s => s.pokemons);
  public trackByEntity: TrackByFunction&lt;Entity&lt;Pokemon>> = trackByEntity;

}</code></pre>

    <pre>
<code class="language-xml">&lt;h1>Pokemon&lt;/h1>
    
&lt;div *ngFor="let pokemon of pokemons; trackBy: trackByEntity">{{ '{' + '{' }} pokemon | json }}&lt;/div></code></pre>

    <p>
        This time, the result is:
    </p>

    <div class="img">
        <img src="assets/img/get-entities.png" />
    </div>

    <p>
        As you can see, an entity is an object with a <code class="language-typescript">value</code> property that
        contains the actual object you want to use. It also contains other properties used by "ng-store" to maintain the
        store in a consistent state. We will see later in this document that you can use some of these properties to
        update the UI of your component based on the state of the entities in the store.
    </p>

    <p class="message information">
        In this case, we use <code class="language-typescript">trackByEntity</code> as we are dealing with entities.
    </p>

    <p>
        It is also possible to find a value or an entity in the store based on its "id" using <code
              class="language-typescript">findValueByKey</code> or <code
              class="language-typescript">findEntityByKey</code>. For example, here is how you would find the Pokemon
        with the "id" of 1
    </p>

    <pre>
<code class="language-typescript">public firstValue: Pokemon | null = this._store.findValueByKey(s => s.pokemons, 1);
public firstEntity: Entity&lt;Pokemon> | null = this._store.findEntityByKey(s => s.pokemons, 1);</code></pre>

    <p>
        Note that these functions return <code class="language-typescript">null</code> if the entity is not found.
    </p>

    <p>
        It is also possible to find values or entities in the store based on any other criteria using the functions
        <code class="language-typescript">findValuesBy</code> or <code
              class="language-typescript">findEntitiesBy</code>. In the following example, we'll find all "normal"
        pokemons.
    </p>

    <pre>
<code class="language-typescript">public normalValues: Pokemon[] = this._store.findValuesBy(s => s.pokemons, p => p.type === 'normal');
public normalEntities: Entity&lt;Pokemon>[] = this._store.findEntitiesBy(s => s.pokemons, e => e.value.type === 'normal');</code></pre>

    <p class="message warning">
        Using <a href="#indexes">indexes</a> can greatly improve the performance of finding values in the store,
        especially when dealing with
        large amounts of data. It is highly recommended to use indexes whenever possible, especially when finding values
        based on properties other than the "id".
    </p>

    <p>
        The functions <code class="language-typescript">findEntityBy</code> and <code
              class="language-typescript">findValueBy</code> can be used to locate the first entity or value that meets
        the specified condition.
    </p>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/01_Find"
           target="_blank">this example</a> of the playground.
    </p>

    <h1 id="select">Select functions</h1>

    <p>
        In the previous chapter, we learned how to retrieve values from the store. It's important to note that the store
        is <strong>immutable</strong>. You can confirm this by attempting to modify a value retrieved from the store,
        like this:
    </p>

    <pre>
<code class="language-typescript">let pokemon: Pokemon | null = this._store.findValueByKey(s => s.pokemons, 1);

if (pokemon !== null) {{ '{' }}
  pokemon.name = 'Super pikachu';
}</code></pre>

    <p>
        This will produce the following error in the console:
    </p>

    <div class="img">
        <img src="assets/img/immutable-error.png" />
    </div>

    <p>
        Certainly, the values in the store are <strong>immutable</strong>, which means that you cannot directly modify
        them as shown in the example. If you are not familiar with immutability, it may seem strange at first, but it is
        highly recommended to learn more about the concept to understand why it is generally considered a best practice
        to store objects in this manner.
    </p>

    <p>
        There are several methods for implementing immutability in JavaScript, and ng-store uses a powerful library
        called <a href="https://github.com/immerjs/immer"
           target="_blank">immer</a> to achieve this. While we won't delve into the details of how immer works in this
        context, it is highly recommended to learn more about it if you wish to understand the inner workings of
        ng-store.
    </p>

    <p>
        It is important to note that due to immutability, objects retrieved from the store using <a href="find">find
            functions</a> may not always reflect the most current data. For example, if you retrieve a value from the
        store using a find function and that value is subsequently modified in the store, the object that you have a
        reference to will not be modified. Instead, a new object will be created to reflect the changes. This means that
        you need a way to know when a value has been modified in order to update your component accordingly, and this is
        where select functions come in. They allow you to monitor for changes in the store and refresh your component as
        needed.
    </p>

    <p>
        Basically, select functions are similar to find functions, but they return observables rather than values or
        entities. For example:
    </p>

    <pre>
<code class="language-typescript">public values$: Observable&lt;Pokemon[]> = this._store.selectValues(s => s.pokemons);
public entities$: Observable&lt;Entity&lt;Pokemon>[]> = this._store.selectEntities(s => s.pokemons);</code></pre>

    <p>
        As shown, you can use <code class="language-typescript">selectValues</code> and <code
              class="language-typescript">selectEntities</code> in the same way as <code
              class="language-typescript">getValues</code> and <code class="language-typescript">getEntities</code>. The
        only difference is that these functions return observables instead of the actual values or entities. In terms of
        templates, the code is largely the same.
    </p>

    <pre>
<code class="language-xml">&lt;h1>Values&lt;/h1>

&lt;div *ngFor="let pokemon of values$ | async; trackBy: trackByValue">{{ '{' + '{' }} pokemon | json }}&lt;/div>

&lt;h1>Entities&lt;/h1>

&lt;div *ngFor="let pokemon of entities$ | async; trackBy: trackByEntity">{{ '{' + '{' }} pokemon | json }}&lt;/div></code></pre>

    <p>
        The only difference here is that you must use the <code class="language-typescript">async</code> pipe.
    </p>

    <p>
        By using the select functions, you can ensure that your component will be notified every time the values you
        retrieved are changed. Another significant advantage is that you can use the <code
              class="language-typescript">async</code> pipe to refresh the component's view in a way that is compatible
        with the "OnPush" change detection strategy.
    </p>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/02_Select"
           target="_blank">this example</a> of the playground.
    </p>

    <h1 id="indexes">Indexes</h1>

    <p>
        In the previous example, we saw how to select values based on criteria other than their key. While this method
        works, it is not optimal in terms of performance. For example:
    </p>

    <pre>
<code class="language-typescript">public normal: Observable&lt;Pokemon[]> = this._store.selectValuesBy(s => s.pokemons, p => p.type === 'normal');</code></pre>

    <p>
        The issue with this approach is that when the store is updated, it will emit its new value and the predicate
        will be executed for all pokemons again. While this may not be a problem for stores with fewer than 10,000
        items, it can be resource-intensive to examine a large number of pokemons just to return the normal ones. In
        these cases, it is recommended to use indexes instead. An index is a property of the object that the store uses
        to efficiently organize its content.
    </p>

    <p>
        To use indexes, the first step is to define them when using <code
              class="language-typescript">createEntities</code>:
    </p>

    <pre>
<code class="language-typescript">export const initial: AppState = {{ '{' }}
    pokemons: createEntities&lt;Pokemon>([ ... ], ['type'])
}</code></pre>

    <p>
        To define indexes in the second parameter of <code class="language-typescript">createEntities</code>, pass an
        array of property names that will be used as indexes. While ng-store supports multiple indexes, it is generally
        best to only include the ones that will be most frequently used, as maintaining multiple indexes can have a
        small performance cost. Keep in mind that it is usually unnecessary to define every property as an index.
    </p>

    <p>
        To use the defined index, you can call either <code class="language-typescript">findValuesByIndex</code> or
        <code class="language-typescript">selectValuesByIndex</code>. These functions allow you to quickly retrieve
        values from the store using the defined index, which can improve the performance of your application by avoiding
        the need to search through all entities to find the desired values.
    </p>

    <pre>
<code class="language-typescript">public normal: Observable&lt;Pokemon[]> = this._store.selectValuesByIndex(s => s.pokemons, 'type', 'normal');</code></pre>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/03_Indexes"
           target="_blank">this example</a> of the playground.
    </p>

    <h1 id="upsert">Upsert</h1>

    <p>
        To update the store, you can use either the <code class="language-typescript">upsertValue</code> or <code
              class="language-typescript">upsertValues</code> functions. These functions allow you to add or update an
        entity or multiple entities in the store based on their keys. If an entity with a matching key already exists in
        the store, it will be merged with the entity you pass to these functions. Note that <code
              class="language-typescript">upsertValues</code> expects an array and is used to upsert one or more
        entities at a time, while <code class="language-typescript">upsertValue</code> is used to upsert a single
        entity.
    </p>

    <p>
        Say that you have the following component:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent {{ '{' }}

  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public pokemons$: Observable&lt;Pokemon[]> = this._store.selectValues&lt;Pokemon>(s => s.pokemons).pipe(
    map(pokemons => pokemons.sort((p1, p2) => p1.name.localeCompare(p2.name)))
  );

  public trackByValue: TrackByFunction&lt;Pokemon> = trackByValue;

  public upsertNonExisting(): void {{ '{' }}

  }

  public upsertExisting(): void {{ '{' }}

  }

  public updateExisting(): void {{ '{' }}
    
  }
}</code></pre>

    <p>
        With the following template:
    </p>

    <pre>
<code class="language-xml">&lt;div *ngFor="let p of pokemons$ | async; trackBy: trackByValue">
    {{ '{' + '{' }} p.name }}
&lt;/div>

&lt;div>
    &lt;button (click)="upsertNonExisting()">Upsert non existing&lt;/button>
&lt;/div>
&lt;div>
    &lt;button (click)="upsertExisting()">Upsert existing&lt;/button>
&lt;/div>
&lt;div>
    &lt;button (click)="updateExisting()">Update existing&lt;/button>
&lt;/div></code></pre>

    <p>
        This component displays a list of all pokemons stored in the store, sorted in alphabetical order by the name
        property. It also has three buttons that allow you to manipulate the data in the store:
    </p>

    <ul>
        <li>The first button upserts a new pokemon entity to the store.</li>
        <li>
            The second button upserts an existing pokemon entity with new data, to demonstrate the update behavior of
            the <code class="language-typescript">upsertValue</code> function.
        </li>
        <li>The third button updates a specific property of an existing pokemon entity in the store.</li>
    </ul>

    <p>
        Here is the code of the first button:
    </p>

    <pre>
<code class="language-typescript">public upsertNonExisting(): void {{ '{' }}
  const pokemon: Pokemon = {{ '{' }}
    id: 13,
    name: 'Vulpix',
    type: 'fire'
  };

  this._store.upsertValue&lt;Pokemon>(s => s.pokemons, pokemon);
}</code></pre>

    <p>
        This couldn't be easier. Simply pass the value you want to add to the store and it will be added. If you want to
        update an existing value, it's just as simple - pass the updated value to the store.
    </p>

    <pre>
<code class="language-typescript">public upsertExisting(): void {{ '{' }}
  const pokemon: Pokemon = {{ '{' }}
    id: 1,
    name: 'Zubat',
    type: 'poison'
  };

  this._store.upsertValue&lt;Pokemon>(s => s.pokemons, pokemon);
}</code></pre>

    <p>
        In this example, we're updating the value with key 1 with a new value. However, if you don't have an object
        containing all of the data for the entity you want to update, you can use the <code
              class="language-typescript">updateValueByKey</code> function to make
        custom updates to the entity.
    </p>

    <pre>
<code class="language-typescript">public updateExisting(): void {{ '{' }}
  this._store.updateValueByKey(s => s.pokemons, 1, p => p.name = 'Jigglypuff');
}</code></pre>

    <p>
        Initially, let's see what the component displays:
    </p>

    <div class="img">
        <img src="assets/img/upsert-01.png" />
    </div>

    <p>
        Next, let's click on the first button:
    </p>

    <div class="img">
        <img src="assets/img/upsert-02.png" />
    </div>

    <p>
        Vulpix was added to the list and, because we're using an observable, the view was automatically refreshed even
        though we're using the "OnPush" change detection strategy. Now, go ahead and click the second button.
    </p>

    <div class="img">
        <img src="assets/img/upsert-03.png" />
    </div>

    <p>
        Pikachu was replaced by Zubat. And finally, click the third button:
    </p>

    <div class="img">
        <img src="assets/img/upsert-04.png" />
    </div>

    <p>
        Zubat was updated and changed into Jigglypuff.
    </p>

    <p>In addition to these functions, you can also use the following ones:</p>

    <ul>
        <li><strong>updateEntitiesBy</strong>: Update <strong>entities</strong> based on a predicate.</li>
        <li><strong>updateEntityByKey</strong>: Update an <strong>entity</strong> based on its key.</li>
        <li><strong>updateValuesBy</strong>: Update <strong>values</strong> based on a predicate.</li>
    </ul>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/04_Upsert"
           target="_blank">this example</a> of the playground.
    </p>

    <h1 id="remove">Remove</h1>

    <p>
        To remove values from the store, you can use these two functions:
    </p>

    <ul>
        <li><strong>removeValuesBy</strong>: Removes values based on a predicate.</li>
        <li><strong>removeValuesByKeys</strong>: Removes values based on their key.</li>
    </ul>

    <p>
        For instance, to remove the values with key 1 or 2:
    </p>

    <pre>
<code class="language-typescript">public remove(): void {{ '{' }}
    this._store.removeValuesByKeys&lt;Pokemon>(s => s.pokemons, 1, 2);
}</code></pre>

    <p>
        Or to remove all normal pokemons:
    </p>

    <pre>
<code class="language-typescript">public removeNormal(): void {{ '{' }}
    this._store.removeValuesBy(s => s.pokemons, p => p.type === 'normal');
}</code></pre>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/05_Remove"
           target="_blank">this example</a> of the playground.
    </p>

    <h1 id="load">Load</h1>

    <p>
        So far, we've covered how to use the store in a synchronous manner. However, in a real-world scenario, data in
        the store is often loaded asynchronously from a REST API. While you can do this with what we've already learned,
        ng-store provides built-in support for asynchronous data loading, as well as components to make it easier to
        work with in the UI. Let's start with a simple example:
    </p>

    <ul>
        <li>Pokemons are loaded from a REST API.</li>
        <li>We want to load all the pokemons, but only some of their properties to save bandwidth (partial load).</li>
        <li>We want a component that displays a pokemon based on its key, including all of its properties.</li>
    </ul>

    <p>
        To run the examples in the playground, I'm using the "json-server" library to create a fake web service. You can
        start it by running the command <code class="language-typescript">yarn json</code> in the playground directory.
        All of the calls have a latency of one second so you can observe what happens during the data loading process.
    </p>

    <p>
        To use HTTP calls with ng-store when using the module approach, you'll need to configure it as follows::
    </p>

    <pre>
<code class="language-typescript">@NgModule({{ '{' }}
    imports: [
        NgStoreModule,
        HttpClientModule
    ],
    providers: [
        {{ '{' }}
            provide: NG_STORE_CONFIG,
            useValue: {{ '{' }}
                initialValue: initial
            } as StoreConfiguration
        }
    ]
})
export class AppModule {{ '{' }} }
</code></pre>

    <p>
        However, if you're using a standalone application, you'll need to configure it as follows:
    </p>

    <pre>
<code class="language-typescript">provideStore({{ '{' }}
  initialValue: initialLoadExample
}),
provideHttpClient()
</code></pre>

    <p>
        Next, we'll create a <code class="language-typescript">PokemonService</code> to handle the process of loading
        data:
    </p>

    <pre>
<code class="language-typescript">@Injectable({{ '{' }}
    providedIn: 'root'
})
export class PokemonService {{ '{' }}

    private _store: NgStore&lt;AppState> = inject(NgStore);

}</code></pre>

    <p>Earlier, we discussed how you can make the HTTP call yourself and manage the loading, error, and success states
        manually. However, ng-store provides a component called <code class="language-typescript">ngs-container</code>
        to simplify this process. In this section, we'll cover the basic usage of <code
              class="language-typescript">ngs-container</code>, but you can find more information about it later in this
        documentation.</p>

    <p>
        The <code class="language-typescript">ngs-container</code> component operates using two observables:
    </p>

    <ul>
        <li><strong>query$</strong>: Performs the HTTP call.</li>
        <li><strong>data$</strong>: Retrieves data from the store to use in the template.</li>
    </ul>

    <p>
        For this example, we'll begin by implementing the function used to fetch data from a REST API in our service:
    </p>

    <pre>
<code class="language-typescript">public loadPokemons(): Observable&lt;Pokemon[]> {{ '{' }}
    return this._store.loadAllEntities('http://localhost:3000/pokemons', s => s.pokemons, false);
}</code></pre>

    <p>
        The <code class="language-typescript">loadAllEntities</code> function is used to load all entities from the
        server and store them in a specific section. It can accept up to four parameters:
    </p>

    <ul>
        <li>
            <strong>url</strong>: URL to call to retrieve the data.
        </li>
        <li>
            <strong>root</strong>: Predicate used to select the section of the store that will store the fetched data.
        </li>
        <li>
            <strong>entityLoaded</strong>: Indicates whether the loaded entities are complete or not (more on that
            later).
        </li>
        <li>
            <strong>force</strong>: When data are loaded and stored in the store, subsequent calls to <code
                  class="language-typescript">loadAllEntities</code> for the same section will return the stored data
            instead of calling the REST API again. However, you can force the store to refetch the data by setting this
            parameter to <code class="language-typescript">true</code>.
        </li>
    </ul>

    <p>
        In this case, we use this function to call the web service at the specified URL and store the values returned by
        it in the "pokemons" section of the store. Additionally, since this route only returns <strong>some</strong>
        properties of the pokemons, we set the third parameter to <strong>false</strong> to indicate to the store that
        the entities are partially loaded (we'll use this fact later).
    </p>

    <p>
        Now that we have this function, we can update the code of our component like this:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent {{ '{' }}

  private readonly _pokemonService = inject(PokemonService);
  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public selectedId: number | null = null;

  public query$: Observable&lt;Pokemon[]> = this._pokemonService.loadPokemons();
  public pokemons$: Observable&lt;Pokemon[]> = this._store.selectValues&lt;Pokemon>(s => s.pokemons).pipe(
    map(pokemons => pokemons.sort((p1, p2) => p1.name.localeCompare(p2.name)))
  );

  public trackByValue: TrackByFunction&lt;Pokemon> = trackByValue;

}
</code></pre>

    <p>
        We set the <code class="language-typescript">query$</code> observable to the value returned by our service
        function and the <code class="language-typescript">data$</code> observable to a
        selection from the store. We also use the <code class="language-typescript">map</code> operator to sort the
        result based on the pokemons' name. Once we
        have these observables, we can use them in the template along with the <code
              class="language-typescript">ngs-container</code> component. The <code
              class="language-typescript">selectedId</code>
        variable will be used to display a pokemon in another component.
    </p>

    <pre>
<code class="language-xml">&lt;ngs-container [query$]="query$"
               [data$]="pokemons$"
               loaderType="text">
    &lt;ng-template let-pokemons>
        &lt;div class="flex-row flex-aic gap1"
             *ngFor="let p of pokemons; trackBy: trackByValue">
            &lt;div>{{ '{' + '{' }} p.name }}&lt;/div>
            &lt;i class="fa fa-solid fa-eye pointer"
               (click)="selectedId = p.id">&lt;/i>
        &lt;/div>
    &lt;/ng-template>
&lt;/ngs-container>
</code></pre>

    <p class="message information">
        If you're using standalone components, you'll need to import <code
              class="language-typescript">NgStoreContainerComponent</code>.
    </p>

    <p>
        The <code class="language-typescript">ngs-container</code> component expects the two observables we mentioned,
        instantiates an <code class="language-typescript">ng-template</code>, and passes
        the values emitted by the <code class="language-typescript">data$</code> observable to its implicit variable. In
        this case, we store these data in the <code class="language-typescript">pokemons</code> variable and use it to
        display all the pokemons. We also display a small icon that sets the value of <code
              class="language-typescript">selectedId</code> to the pokemon id.
    </p>

    <p>
        One of the advantages of the ngs-container component is that it handles loading and error states. If the HTTP
        call fails, the container component catches it and can do something with the error. By default, it simply
        displays it. However, you can configure the container to display the error in a custom way. As for the loading
        indicator, the json server is configured to have a latency of one second and during this time, the <code
              class="language-typescript">ngs-container</code> component displays "<em>Loading...</em>". There are
        different possibilities for the loading indicator format, but in this case, we set the <code
              class="language-typescript">loaderType</code> property to <code class="language-typescript">text</code> to
        simply display a loading sentence. We'll see in the <a href="#ngs-container">ngs-container</a> chapter how to
        customize this loading indicator. Let's confirm all of this by running our application with the JSON server
        turned off:
    </p>

    <div class="img">
        <img src="assets/img/container-error.png" />
    </div>

    <p>
        The <code class="language-typescript">ngs-container</code> component correctly caught the error and displayed
        it. Now, let's start the JSON server and refresh our page. Initially, we can see:
    </p>

    <div class="img">
        <img src="assets/img/container-loading-01.png" />
    </div>

    <p>
        Then after one second:
    </p>

    <div class="img">
        <img src="assets/img/container-loading-02.png" />
    </div>

    <p>
        As you can see, the <code class="language-typescript">ngs-container</code> component handles everything you need
        to fetch the data and display what needs to be displayed based on the current state of the request.
    </p>

    <p>
        We'll go further by creating a component that will receive the id of a pokemon as input and display all its
        data. As we said earlier, the call we used in the main component only loaded some of the properties. Now, we'll
        see how to load all the properties of the pokemon with the specified id. First, let's add a method to our
        service to load a pokemon based on its id.
    </p>

    <pre>
<code class="language-typescript">public loadPokemonById(id: number): Observable&lt;Pokemon> {{ '{' }}
    return this._store.loadEntityByKey(`http://localhost:3000/pokemons-full/${{ '{' }}id}`, s => s.pokemons, id);
}
</code></pre>

    <p class="message information">
        This route fetches a pokemon based on its id and returns all of its properties.
    </p>

    <p>
        The <code class="language-typescript">loadEntityByKey</code> function calls a route to load an entity if it is
        not yet in the store or if it is in the store but is flagged as not completely loaded, which is the case here.
        We called <code class="language-typescript">loadAllEntities</code> by passing <code
              class="language-typescript">false</code> as the third parameter, indicating that the loaded entities were
        not complete. Note that <code class="language-typescript">loadEntityByKey</code> also sets the entity it loads
        as completely loaded (unless you pass <code class="language-typescript">false</code> in its fourth parameter).
        This means that calling this function twice for the same entity will only call the REST API once. Additionally,
        for all loading functions in "ng-store," if multiple components try to load an entity at the same time, only one
        call is made but the entity will be available for all components.
    </p>

    <p>
        Now that we have this function, we can use it in a new component to fetch and display the full data for a
        pokemon based on its id:
    </p>

    <pre>
<code class="language-typescript">@Component({{ '{' }}
  selector: 'app-pokemon',
  templateUrl: './pokemon.component.html',
  changeDetection: ChangeDetectionStrategy.OnPush,
  standalone: true,
  imports: [
    JsonPipe,
    NgStoreContainerComponent
  ]
})
export class PokemonComponent {{ '{' }}

  @Input()
  public set id(value: number) {{ '{' }}
    this.query$ = this._pokemonService.loadPokemonById(value);
    this.pokemon$ = this._store.selectValueByKey(s => s.pokemons, value);
  }

  private readonly _pokemonService = inject(PokemonService);
  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public query$!: Observable&lt;Pokemon>;
  public pokemon$!: Observable&lt;Pokemon | null>;

}
</code></pre>

    <p>
        The idea for this component is similar to the first one, but the <code class="language-typescript">query$</code>
        and <code class="language-typescript">data$</code> observables are defined in the setter of the id input. These
        observables can then be used in the template to display the full data for a pokemon based on its id:
    </p>

    <pre>
<code class="language-xml">&lt;ngs-container [query$]="query$"
    [data$]="pokemon$"
    loaderType="text">
    &lt;ng-template let-pokemon>
        &lt;pre>{{ '{' + '{' }} pokemon | json }}&lt;/pre>
    &lt;/ng-template>
&lt;/ngs-container>
</code></pre>

    <p>
        The only step remaining is to add the following line in the template of the main component:
    </p>

    <pre>
<code class="language-xml">&lt;app-pokemon *ngIf="selectedId !== null"
             [id]="selectedId">&lt;/app-pokemon>
</code></pre>

    <p>
        And that's it! Let's take a look at the network tab in the console to see what happens in terms of HTTP calls
        when the application starts:
    </p>

    <div class="img">
        <img src="assets/img/load-console-01.png" />
    </div>

    <p>
        Now, click on the eye icon of the first pokemon:
    </p>

    <div class="img">
        <img src="assets/img/load-console-02.png" />
    </div>

    <p>
        We see that the call to the route loading all the pokemon properties is correctly executed. Now, let's click on
        the eye of the second pokemon then click again on the eye of the first pokemon:
    </p>

    <div class="img">
        <img src="assets/img/load-console-03.png" />
    </div>

    <p>
        As you can see, the call for the second PokÃ©mon is correctly made, but the call for the first PokÃ©mon is not
        made again. This is because the entity is already in the store and is fully loaded, so it does not need to be
        loaded again. Note that you can force the query to refresh the data by passing <code
              class="language-typescript">true</code> as the fifth parameter.
    </p>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/06_Load"
           target="_blank">this example</a> of the playground.
    </p>

    <p>
        Let's add some complexity to our example by simulating a REST API that uses a relational database. Instead of
        storing the type of each pokemon as a string property, we will have a separate route that returns all available
        types. In this case, the <code class="language-typescript">type</code> property will be replaced by the <code
              class="language-typescript">typeId</code> property, which contains the ID of the
        type for each pokemon.
    </p>

    <p>
        Furthermore, we want to update our main component to display a list of all the pokemon types and, in a separate
        component, a list of all the pokemons for the selected type. First, let's create our models.
    </p>

    <p>
        The pokemon model:
    </p>

    <pre>
<code class="language-typescript">export type Pokemon = BaseEntity&lt;number> & {{ '{' }}
    name: string;
    typeId: number;
}
</code></pre>

    <p>
        And the type one:
    </p>

    <pre>
<code class="language-typescript">export type Type = BaseEntity&lt;number> & {{ '{' }}
    name: string;
}
</code></pre>

    <p>
        Now let's update our state:
    </p>

    <pre>
<code class="language-typescript">export type AppState = {{ '{' }}
    pokemons: Entities&lt;Pokemon>;
    types: Entities&lt;Type>;
}

export const initial: AppState = {{ '{' }}
    pokemons: createEntities&lt;Pokemon>([], ['typeId']),
    types: createEntities&lt;Type>()
}
</code></pre>

    <p>
        Now, it's time to update our service. The first function we will implement is responsible for loading all the
        types into the store.
    </p>

    <pre>
<code class="language-typescript">public loadTypes(): Observable&lt;Type[]> {{ '{' }}
    return this._store.loadAllEntities('http://localhost:3000/types', s => s.types);
}
</code></pre>

    <p>
        Next, let's make the necessary changes in our main component to display all these types:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent {{ '{' }}

  private readonly _pokemonService = inject(PokemonService);
  private readonly _store: NgStore&ltAppState> = inject(NgStore);

  public selectedId: number | null = null;

  public query$: Observable&lt;Type[]> = this._pokemonService.loadTypes();
  public types$: Observable&lt;Type[]> = this._store.selectValues&lt;Type>(s => s.types).pipe(
    map(types => types.sort((t1, t2) => t1.name.localeCompare(t2.name)))
  );

  public trackByValue: TrackByFunction&lt;Pokemon> = trackByValue;

}
</code></pre>

    <pre>
<code class="language-xml">&lt;ngs-container [query$]="query$"
               [data$]="types$"
               loaderType="text">
    &lt;ng-template let-types>
        &lt;div class="flex-row flex-aic gap1"
             *ngFor="let t of types; trackBy: trackByValue">
            &lt;div>{{ '{' + '{' }} t.name }}&lt;/div>
            &lt;i class="fa fa-solid fa-eye pointer"
               (click)="selectedId = t.id">&lt;/i>
        &lt;/div>
    &lt;/ng-template>
&lt;/ngs-container>

&lt;app-pokemon-by-type *ngIf="selectedId !== null"
                     [id]="selectedId">&lt;/app-pokemon-by-type>
</code></pre>

    <p>
        The only difference so far is that the component displaying all the pokemons of the selected type is called
        <code class="language-typescript">app-pokemon-by-type</code>, and it is in this component that we will learn how
        to load dependent data. By "dependent data," I mean data that depends on another entity. In this case, we will
        load the pokemons based on their type. To make it easier to load the pokemons with the store, we should first
        add a property to our "type" model:
    </p>

    <pre>
<code class="language-typescript">export type Type = BaseEntity&lt;number> & {{ '{' }}
    name: string;

    pokemonsLoaded: boolean;
}
</code></pre>

    <p>
        The <code class="language-typescript">pokemonsLoaded</code> property will be used by the store to determine
        whether the pokemons of that type have already been loaded. If the property is not defined, the store will
        assume that the pokemons have not been loaded and will load them accordingly. Currently, this property is not
        optional and must be defined. If you need to manually insert data into the store, you should set this property
        to <code class="language-typescript">false</code> to indicate that the pokemons have not been loaded.
    </p>

    <p>
        Now, it's time to update our service to implement a function that will load pokemons for a specific type if they
        have not been loaded yet.
    </p>

    <pre>
<code class="language-typescript">import {{ '{' }} findStoreValueByKey, NgStore } from "@ssougnez/ng-store";
    
public loadPokemonByType(id: number): Observable&lt;Pokemon[]> {{ '{' }}
    return this._store.loadEntities&lt;Pokemon, Type>(
        `http://localhost:3000/pokemons-with-type?typeId=${{ '{' }}id}`, 
        s => s.pokemons,
        findStoreValueByKey(s => s.types, id),
        'pokemonsLoaded',
        false
    );
}
</code></pre>

    <p>
        We can use the <code class="language-typescript">loadEntities</code> function to load entities based on the
        property of another entity. The first two parameters are the same as in the other functions. The third and
        fourth parameters are what make this function unique. The third parameter allows you to find the dependent
        entity. In most cases, you will use the <code class="language-typescript">findStoreValueByKey</code> utility
        function to do so. Simply pass it the section of the store where you want to find the dependent entity and its
        ID. The fourth parameter is the name of the property that will be used to determine whether the entities have
        been loaded or not. This must be passed as a string to allow the store to update this property as needed (which
        means you should never update the value of this property yourself). The last parameter is the same as in the
        other functions and determines whether the entities are fully or partially loaded (in that case, they are only
        partially loaded).
    </p>

    <p>
        Now that we have this function, we can implement the component that displays the pokemons for a specific type:
    </p>

    <pre>
<code class="language-typescript">export class PokemonByTypeComponent {{ '{' }}

  @Input()
  public set id(value: number) {{ '{' }}
    this.query$ = this._pokemonService.loadPokemonByType(value);
    this.pokemons$ = this._store.selectValuesByIndex&lt;Pokemon>(s => s.pokemons, 'typeId', value);
  }

  private readonly _pokemonService = inject(PokemonService);
  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public trackByValue: TrackByFunction&lt;Pokemon> = trackByValue;

  public query$!: Observable&lt;Pokemon[]>;
  public pokemons$!: Observable&lt;Pokemon[]>;

}
</code></pre>

    <pre>
<code class="language-html">&lt;ngs-container [query$]="query$"
               [data$]="pokemons$"
               loaderType="text">
    &lt;ng-template let-pokemons>
        &lt;div *ngFor="let p of pokemons; trackBy: trackByValue">{{ '{' + '{' }} p.name }}&lt;/div>
    &lt;/ng-template>
&lt;/ngs-container>
</code></pre>

    <p>
        And that's it! If you run your application, you will have:
    </p>

    <div class="img">
        <img src="assets/img/dependent-01.png" />
    </div>

    <p>
        And when you click on the eye icon next to a type:
    </p>

    <div class="img">
        <img src="assets/img/dependent-02.png" />
    </div>

    <p>
        As with the other functions, it's important to note that:
    </p>

    <ul>
        <li>
            Entities are only loaded if they have not yet been loaded. You can override this behavior by using the <code
                  class="language-typescript">force</code> parameter.
        </li>
        <li>
            If multiple components try to load the same dependent data at the same time, only one call is made.
        </li>
    </ul>


    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/07_Load_Dependent"
           target="_blank">this example</a> of the playground.
    </p>

    <p>
        There is one more function that you can use to load data into the store: <code
              class="language-typescript">loadEntitiesOnce</code>. This function loads
        entities only once. The store uses the URL of the REST API to determine whether the entities have already been
        loaded or not. This function is fairly straightforward, so I won't provide an example here. However, if you need
        to use it, you can create an issue and I'll update the documentation.
    </p>

    <h1 id="post">Post</h1>

    <p>
        Now that we've seen how to load data with the store, let's move on to creating data. We'll start by creating the
        following models:
    </p>

    <pre>
<code class="language-typescript">export type PokemonType = 'water' | 'fire' | 'electric' | 'grass' | 'bug' | 'normal' | 'poison';

export type Pokemon = BaseEntity&lt;number> & {{ '{' }}
    name: string;
    type: PokemonType;
}

export type PokemonCreationData = {{ '{' }}
    name: string;
    type: PokemonType;
}
</code></pre>

    <p>
        We defined two types:
    </p>

    <ul>
        <li><strong>Pokemon</strong>: The type of our entities.</li>
        <li><strong>PokemonCreationData</strong>: The type of the data sent to the server to create a new pokemon.</li>
    </ul>

    <p>
        In the service, we'll have one function for retrieving all the pokemons:
    </p>

    <pre>
<code class="language-typescript">export class PokemonService {{ '{' }}

    private _store: NgStore&ltAppState> = inject(NgStore);

    public loadPokemons(): Observable&ltPokemon[]> {{ '{' }}
        return this._store.loadAllEntities('http://localhost:3000/pokemons-full', s => s.pokemons);
    }

}
</code></pre>

    <p>
        Finally, the component simply displays all the pokemons:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent {{ '{' }}

  private readonly _pokemonService = inject(PokemonService);
  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public trackByValue: TrackByFunction&lt;Pokemon> = trackByValue;

  public query$: Observable&lt;Pokemon[]> = this._pokemonService.loadPokemons();
  public data$: Observable&lt;Pokemon[]> = this._store.selectValues&lt;Pokemon>(s => s.pokemons).pipe(
    map(pokemons => pokemons.sort((p1, p2) => p1.name.localeCompare(p2.name)))
  );

}
</code></pre>

    <pre>
<code class="language-xml">&lt;ngs-container [query$]="query$"
               [data$]="data$"
               loaderType="text">
    &lt;ng-template let-pokemons>
        &lt;div class="flex-row gap1">
            &lt;div class="flex-1">
                &lt;div *ngFor="let p of pokemons; trackBy: trackByValue">
                    {{ '{' + '{' }} p.name }}
                &lt;/div>
            &lt;/div>
            &lt;div class="flex-1">
                &lt;app-pokemon-add-form>&lt;/app-pokemon-add-form>
            &lt;/div>
        &lt;/div>
    &lt;/ng-template>
&lt;/ngs-container>
</code></pre>

    <p>
        So far, there is nothing new. However, we have added a component called <code
              class="language-xml">app-pokemon-add-form</code> that we will use to
        create new pokemons. Note that the goal is to automatically refresh the list of pokemons after a new one is
        created. Here is the initial version of the code for this component:
    </p>

    <pre>
<code class="language-typescript">type FormData = {{ '{' }}
  name: FormControl&lt;string | null>;
  type: FormControl&lt;PokemonType | null>;
}

@Component({{ '{' }}
  selector: 'app-pokemon-add-form',
  templateUrl: './pokemon-add-form.component.html',
  changeDetection: ChangeDetectionStrategy.OnPush,
  standalone: true,
  imports: [
    AsyncPipe,
    ReactiveFormsModule
  ]
})
export class PokemonAddFormComponent implements OnInit {{ '{' }}

  private readonly _fb = inject(FormBuilder);
  private readonly _pokemonService = inject(PokemonService);
  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public form!: FormGroup&lt;FormData>;

  public ngOnInit(): void {{ '{' }}
    this.form = this._fb.group({{ '{' }}
      'name': new FormControl&lt;string | null>(null, Validators.required),
      'type': new FormControl&lt;PokemonType | null>(null, Validators.required),
    });
  }

  public add() {{ '{' }}

  }
}
</code></pre>

    <pre>
<code class="language-xml">&lt;form [formGroup]="form"
      (ngSubmit)="add()">
    &lt;div>
        &lt;label>
            Name: &lt;input type="text"
                   formControlName="name">
        &lt;/label>
    &lt;/div>
    &lt;div>
        &lt;label>
            Type: &lt;select formControlName="type">
                &lt;option value="water">Water&lt;/option>
                &lt;option value="fire">Fire&lt;/option>
                &lt;option value="electric">Electric&lt;/option>
                &lt;option value="grass">Grass&lt;/option>
                &lt;option value="bug">Bug&lt;/option>
                &lt;option value="normal">Normal&lt;/option>
                &lt;option value="poison">Poison&lt;/option>
            &lt;/select>
        &lt;/label>
    &lt;/div>
    &lt;button type="submit"
            [disabled]="form.valid === false">Create&lt;/button>
&lt;/form>
</code></pre>

    <p>
        We have created a simple form using reactive forms and bound the submit event of the form to the <code
              class="language-typescript">add</code> function. Before implementing this function, we will create the
        <code class="language-xml">addPokemon</code> function in the service that will use the store to perform the
        creation.
    </p>

    <pre>
<code class="language-typescript">public addPokemon(data: PokemonCreationData): Observable&lt;Pokemon> {{ '{' }}
    return this._store.postEntity&lt;Pokemon>('http://localhost:3000/pokemons-full', s => s.pokemons, data);
}
</code></pre>

    <p>
        Creating a new entity with the store is very easy. You just need to call the <code
              class="language-typescript">postEntity</code> function with the following parameters:
    </p>

    <ul>
        <li><strong>url</strong>: The POST URL to call to create the entity.</li>
        <li><strong>root</strong>: A selector used to update the adding state of the entity list (more on that later).
        </li>
        <li><strong>data</strong>: The payload sent to the server to create the entity.</li>
    </ul>

    <p>
        Now, we just need to call this function in our component:
    </p>

    <pre>
<code class="language-typescript">public add() {{ '{' }}
  const data: PokemonCreationData = {{ '{' }}
    name: this.form.value.name!,
    type: this.form.value.type!
  };

  this._pokemonService
    .addPokemon(data)
    .subscribe({{ '{' }}
      next: () => this.form.reset({{ '{' }} name: null, type: null }),
      error: err => console.log(err)
    })
}
</code></pre>

    <p>
        If you test the component, you will notice that it works... sort of. There are two annoying details here:
    </p>

    <ul>
        <li>
            The pokemon gets created, but the page needs to be refreshed to see it.
        </li>
        <li>
            The button is enabled during the REST call, which means that a user could potentially click the button
            multiple times and create the same pokemon more than once.
        </li>
    </ul>

    <p>
        The first point is easy to solve with the store. You just need to update the function in the service as follows:
    </p>

    <pre>
<code class="language-typescript">public addPokemon(data: PokemonCreationData): Observable&lt;Pokemon> {{ '{' }}
    return this._store
        .postEntity&lt;Pokemon>('http://localhost:3000/pokemons-full', s => s.pokemons, data)
        .pipe(
            tap(pokemon => this._store.upsertValue(s => s.pokemons, pokemon))
        );
}
</code></pre>

    <p>
        Basically, we just piped the observable returned by the function to add the value emitted to the "pokemons"
        section of the store. This will only work if your REST API returns the created entity, like JSON server does. If
        your REST API does not return the created entity, you'll need to find another way to refresh your store. Here
        are a few ideas:
    </p>

    <ul>
        <li>
            If your web service does not return any useful value (which it shouldn't), you can pipe the call to <code
                  class="language-typescript">postEntity</code> with a <code
                  class="language-typescript">switchMap</code> to <code
                  class="language-typescript">loadAllEntities</code> with the <code
                  class="language-typescript">force</code> flag to <code class="language-typescript">true</code>.
        </li>
        <li>
            If your web service only returns the id of the created entity, pipe the call to <code
                  class="language-typescript">postEntity</code> with a <code
                  class="language-typescript">switchMap</code> to <code
                  class="language-typescript">loadEntityByKey</code> with this id.
        </li>
        <li>
            If you prefer to use web socket connections, you can call <code
                  class="language-typescript">upsertValue</code> in the callback function that handles the creation of a
            pokemon.
        </li>
    </ul>

    <p>
        If you try your component now, you will notice that the list of pokemons is automatically refreshed. However,
        the button is still enabled during the call. One way to fix this is to do the following:
    </p>

    <pre>
<code class="language-typescript">public adding = false;

public add() {{ '{' }}
  this.adding = true;

  const data: PokemonCreationData = {{ '{' }}
    name: this.form.value.name!,
    type: this.form.value.type!
  };

  this._pokemonService
    .addPokemon(data)
    .pipe(finalize(() => this.adding = false))
    .subscribe({{ '{' }}
      next: () => this.form.reset({{ '{' }} name: null, type: null }),
      error: err => console.log(err)
    })
}
</code></pre>

    <pre>
<code class="language-xml">&lt;button type="submit"
        [disabled]="form.valid === false || adding === true">Create&lt;/button>
</code></pre>

    <p>
        This method would work, but it can be verbose, especially if you have to do this every time you create a
        component that creates data. A better option is to use the store. When you use <code
              class="language-typescript">postEntity</code>, the store automatically maintains the "adding" state of the
        relevant store section. This allows you to achieve the same result with less code:
    </p>

    <pre>
<code class="language-typescript">public adding$: Observable&lt;boolean> = this._store.select(s => s.pokemons).pipe(map(e => e.adding));

public add() {{ '{' }}
  const data: PokemonCreationData = {{ '{' }}
    name: this.form.value.name!,
    type: this.form.value.type!
  };

  this._pokemonService
    .addPokemon(data)
    .subscribe({{ '{' }}
      next: () => this.form.reset({{ '{' }} name: null, type: null }),
      error: err => console.log(err)
    })
}
</code></pre>

    <p>
        You can now use this observable in the template:
    </p>

    <pre>
<code class="language-xml">&lt;button type="submit"
        [disabled]="form.valid === false || (adding$ | async) === true">Create&lt;/button>
</code></pre>

    <p>
        While this may only save a couple lines of code in the short term, this feature becomes very useful in the long
        run.
    </p>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/08_Post"
           target="_blank">this example</a> of the playground.
    </p>

    <h1 id="put">Put</h1>

    <p>
        To show how to update data using the store, we will start with the code from <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/08_Post">the previous
            example</a>. First, we need to modify the model that contains the updated data:
    </p>

    <pre>
<code class="language-typescript">export type PokemonUpsertData = {{ '{' }}
    id: number | null;
    name: string;
    type: PokemonType;
}
</code></pre>

    <p>
        The <code class="language-typescript">id</code> property can be either a number or <code
              class="language-typescript">null</code>, because it can contain
        either an existing entity ID for updates or <code class="language-typescript">null</code> for new entities. As
        for the service:
    </p>

    <pre>
<code class="language-typescript">export class PokemonService {{ '{' }}

    private _store: NgStore&lt;AppState> = inject(NgStore);

    public loadPokemons(): Observable&lt;Pokemon[]> {{ '{' }}
        return this._store.loadAllEntities('http://localhost:3000/pokemons-full', s => s.pokemons);
    }

    public loadPokemonById(id: number): Observable&lt;Pokemon> {{ '{' }}
        return this._store.loadEntityByKey(`http://localhost:3000/pokemons-full/${{ '{' }}id}`, s => s.pokemons, id);
    }

}
</code></pre>

    <p>
        Now, let's modify the main component to display an edit icon next to the names of the pokemons:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent {{ '{' }}

  private readonly _pokemonService = inject(PokemonService);
  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public selectedId: number | null = null;
  public trackByValue: TrackByFunction&lt;Pokemon> = trackByValue;

  public query$: Observable&lt;Pokemon[]> = this._pokemonService.loadPokemons();
  public data$: Observable&lt;Pokemon[]> = this._store.selectValues&lt;Pokemon>(s => s.pokemons).pipe(
    map(pokemons => pokemons.sort((p1, p2) => p1.name.localeCompare(p2.name)))
  );

}
</code></pre>

    <pre>
<code class="language-xml">&lt;ngs-container [query$]="query$"
               [data$]="data$"
               loaderType="text">
    &lt;ng-template let-pokemons>
        &lt;div class="flex-row gap1">
            &lt;div class="flex-1">
                &lt;div class="flex-row flex-aic gap1"
                     *ngFor="let p of pokemons; trackBy: trackByValue">
                    &lt;div>{{ '{' + '{' }} p.name }}&lt;/div>
                    &lt;i class="fa fa-solid fa-edit pointer"
                       (click)="selectedId = selectedId === p.id ? null : p.id">&lt;/i>
                &lt;/div>
            &lt;/div>
            &lt;div class="flex-1">
                &lt;app-pokemon-upsert-form [id]="selectedId">&lt;/app-pokemon-upsert-form>
            &lt;/div>
        &lt;/div>
    &lt;/ng-template>
&lt;/ngs-container>
</code></pre>

    <p>
        The only subtlety here is in the click event of the icon. It changes the <code
              class="language-typescript">selectedId</code> variable to the ID of the
        pokemon to edit, or to <code class="language-typescript">null</code> if <code
              class="language-typescript">selectedId</code> already contains it. This allows you to select the pokemon
        if it was not already selected, or unselect it if it was.
    </p>

    <p>
        The most important code is in the upsert component:
    </p>

    <pre>
<code class="language-typescript">type FormData = {{ '{' }}
  id: FormControl&lt;number | null>;
  name: FormControl&lt;string | null>;
  type: FormControl&lt;PokemonType | null>;
}

export class PokemonUpsertFormComponent implements OnInit {{ '{' }}

  @Input()
  public set id(value: number | null) {{ '{' }}
    this.query$ = value === null ? of(null) : this._pokemonService.loadPokemonById(value);
    this.data$ = value === null ? of(null) : this._store.selectValueByKey(s => s.pokemons, value).pipe(filter(e => e !== null), take(1));
  }

  private readonly _fb = inject(FormBuilder);
  private readonly _pokemonService = inject(PokemonService);
  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public form!: FormGroup&lt;FormData>;

  public busy$: Observable&lt;boolean> = this._store.select(s => s.pokemons).pipe(map(e => e.busy));
  public data$!: Observable&lt;Pokemon | null>;
  public query$!: Observable&lt;Pokemon | null>;

  public ngOnInit(): void {{ '{' }}
    this.form = this._fb.group({{ '{' }}
      'id': new FormControl&lt;number | null>(null),
      'name': new FormControl&lt;string | null>(null, Validators.required),
      'type': new FormControl&lt;PokemonType | null>(null, Validators.required),
    });
  }

  public upsert() {{ '{' }}
    const data: PokemonUpsertData = {{ '{' }}
      id: this.form.value.id!,
      name: this.form.value.name!,
      type: this.form.value.type!
    };

    this._pokemonService
      .upsertPokemon(data)
      .subscribe({{ '{' }}
        next: () => this.form.value.id === null && this.reset(null),
        error: err => console.log(err)
      })
  }

  public reset(pokemon: Pokemon | null) {{ '{' }}
    this.form.reset({{ '{' }}
      id: pokemon?.id || null,
      name: pokemon?.name || null,
      type: pokemon?.type || null
    })
  }

}
</code></pre>

    <p>
        The idea here is that we shouldn't assume that the entity you want to update is already in the store. In a
        real-world scenario, it is more likely that entities will be loaded before they can be updated, but let's
        imagine that's not the case.
    </p>

    <p>
        The <code class="language-typescript">id</code> input can receive two different values:
    </p>

    <ul>
        <li><strong>null</strong>: Indicates that we want to create a new pokemon.</li>
        <li><strong>A number</strong>: Indicates that we want to update the pokemon with that key.</li>
    </ul>

    <p>
        Depending on the value of this input, we will either set the <code class="language-typescript">query$</code> and
        <code class="language-typescript">data$</code> observables to observables that emit the value <code
              class="language-typescript">null</code> (in the case of creation) or to observables used to load and
        select the entity. Note that we use the <code class="language-typescript">filter</code> and <code
              class="language-typescript">take</code> operators to only use the first non-null emitted value. We do this
        for a specific reason. We want to set the value of the form based on the current data of the entity. However, if
        we didn't stop after the first non-null emitted value, we would risk losing our changes during the edit process.
        For example, say you fetch pokemon 1 and set the value of the form based on it. While you are typing the new
        name of the pokemon, the state of the entity changes (perhaps in response to a web socket message). As a new
        value is emitted, the form resets with the new values and you lose all your changes. This is why we use <code
              class="language-typescript">take</code>: to avoid losing the current changes.
    </p>

    <p>
        Next is the <code class="language-typescript">busy$</code> observable. To disable the button, we could check the
        "adding" state of the entity list or the "updating" state of the entity, but there is an easier solution.
        Whenever an entity is being added, deleted, or updated, the "busy" state of the entity list is set to <code
              class="language-typescript">true</code>. So in this case, we can simply use this state to
        know if an entity is being updated or added.
    </p>

    <p>
        In the <code class="language-typescript">ngOnInit</code> method, we simply create our form with default values.
    </p>

    <p>
        In the <code class="language-typescript">upsert</code> function, we create the payload and send it to the <code
              class="language-typescript">upsertPokemon</code> function. Note that we only reset
        the form value in the case of creation. In the case of update, we want to keep the data synchronized with the
        <code class="language-typescript">id</code>
        property.
    </p>

    <p>
        The <code class="language-typescript">reset</code> function resets the form based on the object received as a
        parameter.
    </p>

    <p>
        Now let's look at the template:
    </p>

    <pre>
<code class="language-xml">&lt;ngs-container [query$]="query$"
               [data$]="data$"
               (changed)="reset($event)">
    &lt;ng-template let-pokemon>
        &lt;form [formGroup]="form"
              (ngSubmit)="upsert()">
            &lt;div>
                &lt;label>
                    Name: &lt;input type="text"
                           formControlName="name">
                &lt;/label>
            &lt;/div>
            &lt;div>
                &lt;label>
                    Type: &lt;select formControlName="type">
                        &lt;option value="water">Water&lt;/option>
                        &lt;option value="fire">Fire&lt;/option>
                        &lt;option value="electric">Electric&lt;/option>
                        &lt;option value="grass">Grass&lt;/option>
                        &lt;option value="bug">Bug&lt;/option>
                        &lt;option value="normal">Normal&lt;/option>
                        &lt;option value="poison">Poison&lt;/option>
                    &lt;/select>
                &lt;/label>
            &lt;/div>
            &lt;button type="submit"
                    [disabled]="form.valid === false || (busy$ | async) === true">
                {{ '{' + '{' }} form.value.id === null ? 'Create' : 'Update' }}
            &lt;/button>
        &lt;/form>
    &lt;/ng-template>
&lt;/ngs-container>
</code></pre>

    <p>
        We use the <code class="language-typescript">changed</code> event of the container to execute a function when
        the data emitted by <code class="language-typescript">data$</code> changes. In this
        case, we want to reset the form with the emitted value. Remember, in the case of id being <code
              class="language-typescript">null</code>, we emit the
        value <code class="language-typescript">null</code>, but if id is defined, we emit the first non-null value from
        the store.
    </p>

    <p>
        The last thing to note is the button: it is disabled if the form is invalid or if the <code
              class="language-typescript">busy$</code> observable emits
        <code class="language-typescript">true</code>. Additionally, the label of the button changes depending on the
        <code class="language-typescript">id</code> field of the form.
    </p>

    <p>
        It's important to note that we could have done this in a different way, but using an observable for the busy
        state of the form is important. Since we are using the <code class="language-typescript">OnPush</code> change
        detection strategy, it's important to refresh the view when the state of the form changes. Without this, we
        would need to call <code class="language-typescript">markForCheck</code> on the component to reflect the form
        reset after the update was completed.
    </p>

    <p>
        The final piece of the puzzle is the <code class="language-typescript">upsertPokemon</code> function in the
        service:
    </p>

    <pre>
<code class="language-typescript">public upsertPokemon(data: PokemonUpsertData): Observable&lt;Pokemon> {{ '{' }}
    const action$ = data.id === null
        ? this._store.postEntity(`http://localhost:3000/pokemons-full`, s => s.pokemons, data)
        : this._store.putEntityByKey&lt;Pokemon>(`http://localhost:3000/pokemons-full/${{ '{' }}data.id}`, s => s.pokemons, data.id, data);

    return action$.pipe(
        tap(pokemon => this._store.upsertValue(s => s.pokemons, pokemon))
    );
}
</code></pre>

    <p>
        This function is a bit more complicated than it needs to be because of the JSON server. In a real-world
        scenario, you would probably have implemented an upsert function that creates or updates the entity. However,
        the JSON server does not provide a route for both operations. You either have to use a POST request to create
        the entity or a PUT request to update it.
    </p>

    <p>
        However, it's not very complicated. If <code class="language-typescript">data.id</code> is <code
              class="language-typescript">null</code>, we call the <code class="language-typescript">postEntity</code>
        function like we did in the previous example. Otherwise, we call <code
              class="language-typescript">putEntityByKey</code>, which behaves the same as <code
              class="language-typescript">postEntity</code> but requires the key of the entity as the third parameter.
        Because both functions return the same type of object, you can store it in a single variable and pipe it to
        update the store once the call is completed.
    </p>

    <p>
        And that's it! You now have a component that can easily add or update an entity.
    </p>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/09_Put"
           target="_blank">this example</a> of the playground.
    </p>

    <h1 id="delete">Delete</h1>

    <p>
        The final operation we need to support is deleting values from the store. Here are the relevant parts of the
        example:
    </p>

    <p>
        First, the model:
    </p>

    <pre>
<code class="language-typescript">export type Pokemon = BaseEntity&lt;number> & {{ '{' }}
    name: string;
    type: 'water' | 'fire' | 'electric' | 'grass' | 'bug' | 'normal' | 'poison';
}
</code></pre>

    <p>
        Then, the service:
    </p>

    <pre>
<code class="language-typescript">export class PokemonService {{ '{' }}

    private _store: NgStore&lt;AppState> = inject(NgStore);

    public deletePokemon(id: number): Observable&lt;Pokemon> {{ '{' }}
        return this._store.deleteEntityByKey(`http://localhost:3000/pokemons-full/${{ '{' }}id}`, s => s.pokemons, id).pipe(
            tap(pokemon => this._store.removeValuesByKeys(s => s.pokemons, id))
        );
    }

    public loadPokemons(): Observable&lt;Pokemon[]> {{ '{' }}
        return this._store.loadAllEntities('http://localhost:3000/pokemons-full', s => s.pokemons);
    }

}
</code></pre>
<!-- HERE -->
    <p>
        Deleting an item from the store using a REST call can be done using the <code
              class="language-typescript">deleteEntityByKey</code> function. It simply expects the route to the REST
        API, the section of the store to find the entity and its key. Note that this function only calls the route and
        set the <code class="language-typescript">deleting</code> property of the entity to <code
              class="language-typescript">true</code> but does not actually remove the entity from the store, which is
        why we pipe the observable to a call to the <code class="language-typescript">removeValuesByKeys</code> function
        that actually removes the entity from the store. Note that you can pass more than one key if you wish to delete
        multiple entities.
    </p>

    <p>
        There is also another function called <code class="language-typescript">removeValuesBy</code> that can be used
        to remove entities based on a predicate.
    </p>

    <p>
        Now, the code of the main component:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent {{ '{' }}

  private readonly _pokemonService = inject(PokemonService);
  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public query$: Observable&lt;Pokemon[]> = this._pokemonService.loadPokemons();
  public pokemons$: Observable&lt;Entity&lt;Pokemon>[]> = this._store.selectEntities&lt;Pokemon>(s => s.pokemons).pipe(
    map(pokemons => pokemons.sort((p1, p2) => p1.value.name.localeCompare(p2.value.name)))
  );

  public trackByEntity: TrackByFunction&lt;Entity&lt;Pokemon>> = trackByEntity;

  public deletePokemon(id: number) {{ '{' }}
    this._pokemonService
      .deletePokemon(id)
      .subscribe({{ '{' }}
        error: err => console.log(err)
      })
  }
}
</code></pre>

    <p>
        The code is pretty self explanatory but there is one thing worth noticing. So far, we only selected values from
        the store because we didn't need to access their state (adding, updating or deleting). Here, we want to display
        a deleting indicator while the entity is being deleted. To do so, we'll select the pokemon as entities instead
        of as values. This also means that we need to use <code class="language-typescript">trackByEntity</code> instead
        of <code class="language-typescript">trackByValue</code>.
    </p>

    <p>
        And finally the template:
    </p>

    <pre>
<code class="language-xml">&lt;ngs-container [query$]="query$"
               [data$]="pokemons$"
               loaderType="text">
    &lt;ng-template let-pokemons>
        &lt;div class="flex-row flex-aic gap1"
             *ngFor="let p of pokemons; trackBy: trackByEntity">
            &lt;div>{{ '{' + '{' }} p.value.name }}&lt;/div>
            &lt;i class="fa fa-solid fa-trash pointer"
               (click)="deletePokemon(p.value.id)"
               *ngIf="p.deleting === false">&lt;/i>
            &lt;i class="fa fa-spin fa-spinner"
               *ngIf="p.deleting === true">&lt;/i>
        &lt;/div>
    &lt;/ng-template>
&lt;/ngs-container>
</code></pre>

    <p>
        Note that here, we use the <code class="language-typescript">value</code> property of the entities to access the
        actual <code class="language-typescript">Pokemon</code> object. However, we use the property <code
              class="language-typescript">deleting</code> to define whether the displayed icon is the little trash or
        the spinner. This works because the <code class="language-typescript">deleteEntityByKey</code> function updates
        the <code class="language-typescript">deleting</code> property of the entity during deletion, so you don't have
        to handle this yourself.
    </p>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/10_Delete"
           target="_blank">this example</a> of the playground.
    </p>

    <h1 id="ngs-container">ngs-container</h1>

    <p>
        The <code class="language-xml">ngs-container</code> component can be customized in various ways in order to look
        exactly like you want. Let's start by talking about the loading indicator, which can be configured in four
        different ways using the <code class="language-typescript">loaderType</code> property:
    </p>

    <ul>
        <li><strong>text</strong>: Displays a sentence during the loading.</li>
        <li><strong>template</strong>: Displays a custom template during the loading.</li>
        <li><strong>component</strong>: Displays a custom component during the loading.</li>
        <li><strong>none</strong>: Does not display anything during the loading.</li>
    </ul>

    <p>
        If you opt for the "text" approach, you can customize the displayed text in two ways. Either by simply using the
        <code class="language-xml">loaderText</code> attribute:
    </p>

    <pre>
<code class="language-xml">&lt;ngs-container [query$]="query$"
               [data$]="pokemons$"
               loaderType="text"
               loaderText="Wait a minute...">
    &lt;ng-template let-pokemons>
        
    &lt;/ng-template>
&lt;/ngs-container>
</code></pre>

    <p>
        However, you can also use the injection token in order to define the sentence to display globally:
    </p>

    <pre>
<code class="language-typescript">{{ '{' }}
  provide: NG_STORE_CONFIG,
  useValue: {{ '{' }}
    initialValue: initial,
    defaultLoaderText: () => 'This might take a while...'
  } as StoreConfiguration
}
</code></pre>

    <p>
        As this property expects a function, you can use <code class="language-typescript">inject</code> in order to
        inject a translation service that will return the sentence in the desired language. Note that the value of the
        attribute take precedence over the one of the injection token.
    </p>

    <p>
        You can also choose to display a template instead of a loading text:
    </p>

    <pre>
<code class="language-xml">&lt;ngs-container [query$]="query$"
               [data$]="pokemons$"
               [loaderTemplate]="loader"
               loaderType="template">
    &lt;ng-template let-pokemons>
        &lt;div *ngFor="let p of pokemons; trackBy: trackByValue">{{ '{' + '{' }} p.name }}&lt;/div>
    &lt;/ng-template>
&lt;/ngs-container>

&lt;ng-template #loader>
    The data are currently being fetched...
&lt;/ng-template>
</code></pre>

    <p>
        Finally, you can also create a custom component that will be instantiated each time the loading indicator has to
        be displayed. The only requirement is that this component must implement <code
              class="language-typescript">IBaseLoaderComponent</code>:
    </p>

    <pre>
<code class="language-typescript">export class LoaderComponent implements IBaseLoaderComponent {{ '{' }}

  @Input()
  public size: string = '1rem';

}
</code></pre>

    <pre><code class="language-xml">&lt;div [style.fontSize]="size">Please wait a minute during the loading...&lt;/div></code></pre>

    <p>
        This interface forces you to implement a <code class="language-typescript">size</code> property defining the
        size of the loader. Indeed, most of the time, this approach (which is the default one) is used to display an
        animated loading indicator and being able to define its size can come handy (note that you can also specify the
        size directly using the attribute of the container, which superseed the global configuration). Finally, you have
        to adapt the store configuration to specify the component to use:
    </p>

    <pre>
<code class="language-typescript">{{ '{' }}
  provide: NG_STORE_CONFIG,
  useValue: {{ '{' }}
    initialValue: initial,
    loaderComponent: LoaderComponent
  } as StoreConfiguration
}
</code></pre>

    <p>
        You can define the appearance of the errors in the same way you do for loading indicators. By default, the JSON
        representation of the error is displayed in a <code class="language-xml">pre</code> tag. However, you can choose
        to display it in a template:
    </p>

    <pre>
<code class="language-xml">&lt;ngs-container [query$]="query$"
               [data$]="pokemons$"
               [errorTemplate]="error">
    &lt;ng-template let-pokemons>
        
    &lt;/ng-template>
&lt;/ngs-container>

&lt;ng-template #error let-err>
    &lt;div style="color:red">{{ '{' + '{' }} err.message }}&lt;/div>
&lt;/ng-template>
</code></pre>

    <p>
        You can also implement a custom error component with the requirement that it has to implement <code
              class="language-typescript">IBaseErrorComponent</code>:
    </p>

    <pre>
<code class="language-typescript">export class ErrorComponent implements IBaseErrorComponent {{ '{' }}}

  @Input()
  public error: any;

}
</code></pre>

    <pre><code class="language-xml">&lt;div style="color:red">{{ '{' + '{' }} error.message }}&lt;/div></code></pre>

    <p>
        Basically, you just have to implement an <code class="language-typescript">error</code> input that will receive
        the error. Finally, you just have to update the store configuration to take this component into account:
    </p>

    <pre>
<code class="language-typescript">{{ '{' }}
  provide: NG_STORE_CONFIG,
  useValue: {{ '{' }}
    initialValue: initial,
    errorComponent: ErrorComponent
  } as StoreConfiguration
},
</code></pre>

    <p>
        As a reminder, the container component also support the <code class="language-typescript">changed</code> event
        that forwards values emitted by the <code class="language-typescript">data$</code> observable.
    </p>

    <h1 id="store-component">StoreComponent</h1>

    <p>
        When using the store, there is a kind of component that you'll be implementing often. The ones that only display
        one or several values and do nothing else. For example, take the following example:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent {{ '{' }}

  private readonly _pokemonService = inject(PokemonService);
  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public query$: Observable&lt;Pokemon[]> = this._pokemonService.loadPokemons();
  public pokemons$: Observable&lt;Pokemon[]> = this._store.selectValues&lt;Pokemon>(s => s.pokemons).pipe(
    map(pokemons => pokemons.sort((p1, p2) => p1.name.localeCompare(p2.name)))
  );

  public trackByValue: TrackByFunction&lt;Pokemon> = trackByValue;

}
</code></pre>

    <p>
        There are some parts here that are common to all components of this type: the injection of the store, the
        creation of the <code class="language-typescript">query$</code> observable and the creation of the <code
              class="language-typescript">data$</code> observable. In order to avoid having to repeat this on all
        components of that type, the store comes with a base class helping you reduce a bit the boilerplate:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent extends StoreComponent&lt;AppState, Pokemon[]> implements OnInit {{ '{' }}

  private readonly _pokemonService = inject(PokemonService);

  public trackByValue: TrackByFunction&lt;Pokemon> = trackByValue;

  public ngOnInit() {{ '{' }}
    this.query$ = this._pokemonService.loadPokemons();
    this.data$ = this._store.selectValues&lt;Pokemon>(s => s.pokemons).pipe(
      map(pokemons => pokemons.sort((p1, p2) => p1.name.localeCompare(p2.name)))
    );
  }

}
</code></pre>

    <p>
        Note that in this case, you have to use the <code class="language-typescript">data$</code> observable and not
        <code class="language-typescript">pokemon$</code>. The gain here is not obvious but it's more clear when you
        have an input that defines the observables. In that case, you can directly assign them like we did in the <code
              class="language-typescript">ngOnInit</code>.
    </p>

    <p>
        This component will not reduce the size of your bundle by half but it comes handy from time to time.
    </p>

    <h1 id="roadmap">Roadmap</h1>

    <p>
        Here you'll find the next features I'd like to add to this library. Don't hesitate to post an issue to propose
        some ideas ðŸ˜‰
    </p>

    <ul>
        <li>Unit testing</li>
        <li>Consider the possibility to switch to mutative instead of immer</li>
    </ul>

</main>

<app-top-cta></app-top-cta>