<main>

    <div class="logo">

        <div class="title">
            <span>ng-st</span>
            <img src="assets/img/logo.svg"
                 alt="Logo" />
            <span>re</span>
        </div>
    </div>

    <h1>Table of content</h1>

    <ul>
        <li><a href="#context">Context</a></li>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#playground">PLayground</a></li>
        <li><a href="#installation">Installation</a></li>
        <li><a href="#principle">Principle</a></li>
        <li><a href="#models">Models</a></li>
        <li><a href="#state">State</a></li>
        <li><a href="#configuration">Configuration</a></li>
        <li><a href="#find">Find functions</a></li>
        <li><a href="#select">Select functions</a></li>
        <li><a href="#indexes">Indexes</a></li>
    </ul>

    <h1 id="context">Context</h1>

    <p>Managing data in an Angular application can be quite tricky and impact the way you develop your application.
        "ng-store" is a solution to manage data using a store similar to a relational database.</p>

    <h1 id="introduction">Introduction</h1>

    <p>When learning Angular, you'll be confronted to a lot of concepts and challenges that you'll have to take.
        There are so many of those that beginners tend to neglect one of the most important: data management.</p>

    <p>At first, it's tempting to rush into components development to make huge and complex components to power your
        application. After all, at first, it seems easier to have everything in a huge component. However, after a
        while, it appears that it is not a good solution and that it brings more problem that it solves.</p>

    <p>At some point, in the Angular learning journey, one will be confronted to the challenge of managing data in the
        best way possible. At first, it's most likely that one will store data inside a component. Basically, after
        having read some tutorials, one will inject the <code class="language-typescript">HttpClient</code> service into
        the component and call the <code class="language-typescript">get</code> method to fetch data before displaying
        them on the screen.</p>

    <p>It obviously works pretty well, however, there are some attention points to this:</p>

    <ul>
        <li>
            In a perfect world, a component should do one and only one thing. Therefore, fetching data using a HTTP call
            and displaying them could be considered as two things => bad practice.
        </li>
        <li>
            Data loaded in the component are only available in this component.
        </li>
        <li>
            You might need multiple class variables to store these data depending on the complexity of the component.
        </li>
        <li>
            If multiple components need the same data, they will be loaded multiple times.
        </li>
    </ul>

    <p>The next logical step is to start using services to store data. There are avantages to this approach:</p>

    <ul>
        <li>
            Data are centralized: When data are loaded, they are available to multiple components.
        </li>
        <li>
            The heavy lifting is done once by the service. Components needing the data just have to inject the
            service and use the data.
        </li>
    </ul>

    <p>
        However, it's still, in my opinion, not the perfect solution. Indeed, with services maintaining their own data
        arise some pain points:
    </p>

    <ul>
        <li>
            What if the service A needs data from the services B and vice versa. This will create a cyclic dependency
            that will be difficult to solve properly.
        </li>
        <li>
            It's difficult to ensure that services fetch and maintain their data in the same way. This can be leveraged
            using a base class but it adds some complexity.
        </li>
        <li>
            If you're using the "OnPush" change detection strategy (as you should), simply updating data in a service
            won't refresh the views that depend on its data. Indeed, you'll need to implement a system propagating the
            value change down to the components. It's not very complex but it adds unecessary boilerplate.
        </li>
        <li>
            You still have to think and implement a way of fetching data from your back end in a consistent way.
        </li>
    </ul>

    <p>
        I faced all these issues and considerations in my day to day work for a while, which is why I decided to have a
        look at store/state management systems out there.
    </p>

    <p>To be honest, I only checked one out: <a href="https://ngrx.io/"
           target="_blank">ngrx</a>. Mostly because it's the most popular one.
    </p>

    <p>
        Before reading the following lines, please consider that I didn't use it for a long time and I probably only
        scratched the surface so the following lines might not be entirely correct or can be outdated.
    </p>

    <p>
        My general feeling about this library is that it is waaay too complex to use. You have to create actions,
        effects, reducers, selectors, etc... and at the end, everything ties up magically and it becomes pretty
        cumbersome to have a clear view of what's happening in your application or to debug it.
    </p>

    <p>
        Another issue I had with it was the way immutability is handled. Basically, you have to do the heavy lifting
        using the spread operator in order to create new objects based on existing ones. I found it pretty cumbersome
        and not very intuitive (spoiler alert: "ng-store" handles it in a way that is totally transparent to you).
    </p>

    <p>
        Once again, I'm sure it's a perfectly good library but long story short, it didn't suit me.
    </p>

    <p>
        However, I really liked the idea of having one common location to store all the data of the application.
        Besides, the reactivity of the store also charmed me a lot, which is why I decided to implement my own store
        management library.
    </p>

    <p>
        At the time of writing (2023), I've been working on and using this library for two years and now that it is
        stable, I feel that it can be useful to other developers than me.
    </p>

    <p>
        In this documentation, we'll see the basic principle behind ng-store, how to configure and use it. After
        reading, you'll know everything there is about it and if you liked what you read, maybe you'll want to use it in
        your app ðŸ˜€
    </p>

    <h1 id="playground">Playground</h1>

    <p>You can find the code of the examples we'll talk about later in this article in the <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src"
           target="_blank">GitHub playground</a>. The only thing you need to do is update the line 6 of the "main.ts"
        file to change the example you want to build.</p>

    <h1 id="installation">Installation</h1>

    <p>Simply run:</p>

    <pre><code class="language-typescript">yarn add immer @ssougnez/ng-store</code></pre>

    <h1 id="principle">Principle</h1>

    <p>
        You can use "ng-store" the way you want, however, you'll find in this section some advices to use it in an
        optimal way.
    </p>

    <p>
        Basically, the main principle consists in using "flat objects" as musch as possible. What I call "flat objects"
        are objects without any complex properties other than ones containing abstract data. For example, this is not a
        "flat object":</p>

    <pre>
<code class="language-typescript">{{ '{' }}
    firstName: "Nicolas",
    lastName: "Cage",
    age: 50,
    friends: [{{ '{' }}
        firstName: "Nicole",
        lastName: "Kidman",
        age: 56
    }]
}</code></pre>

    <p>
        The issue with this kind of objet is that it is an open door to data redundancy. Indeed, say that you fetch
        these data from a back end using REST API. It is very likely that the different users will have the same
        friends, meaning that a user data might be located in the "friends" array of multiple objects, causing the data
        to be bigger and duplicated. A better version of it would be:
    </p>

    <pre>
<code class="language-typescript">{{ '{' }}
    firstName: "Nicolas",
    lastName: "Cage",
    age: 50,
    friends: [3, 19, 5]
}</code></pre>

    <p>
        In this approach, objects are treated as <strong>entities</strong> identified by a specific property that do not
        contain complex properties other than abstract data. "Abstract data" are data that does not represent entities
        in themselves, for example, some configuration for a specific entity.
    </p>

    <p>
        Basically, you have to think about entities as rows in a relational database. In these, you have regular columns
        storing simple data and when you need more complex data, you store them in another table referenced by a foreign
        key in your primary one. In some circunstance, you'll also create a text column storing abstract data (in JSON).
    </p>

    <p>
        Following this principle will help you a lot using "ng-store", but also for working on your back end. Indeed,
        when you have no real guidelines about the form of the object to return via a web service, it can be difficult
        to know what data to fetch from the database because you're not sure what data will be needed by the REST API
        call. With this approach, most of the time, you'll fetch data from your database in the most basic way.
    </p>

    <h1 id="models">Models</h1>

    <p>
        The core concept of the store is "entities". As explained above, an entity is a basic object with only
        simple properties. It must also contain an "id" property of the type you want. To ensure this last requirement,
        all your entities need to extend the <code class="language-typescript">BaseEntity&lt;T></code> base class
        where "T" is the type of the "id" property. For example, here is an example of a "Pokemon" entity.
    </p>

    <pre>
<code class="language-typescript">import {{ '{' }} BaseEntity } from "@ssougnez/ng-store";

export type Pokemon = BaseEntity&lt;number> & {{ '{' }}
    name: string;
    type: 'water' | 'fire' | 'electric' | 'grass' | 'bug' | 'normal' | 'poison';
}</code></pre>

    <p>
        It's important to highlight the fact that these entities are not stored as such in the store. In the example
        above, a value of type "Pokemon" will be stored as an <code
              class="language-typescript">Entity&lt;Pokemon></code> object. This type
        allows ng-store to store and find values in an efficient way. For now, the most important thing to remember is
        that an object of type <code class="language-typescript">Entity&lt;T></code> contains a <code
              class="language-typescript">value</code> property that holds the actual <code
              class="language-typescript">Pokemon</code> object. The type <code
              class="language-typescript">Entity&lt;T></code> also contains other properties that we'll review later in
        this document.
    </p>

    <p>
        For the rest of this article, we'll use the following terms:
    </p>

    <ul>
        <li><strong>value</strong>: A value is the object you want to store, in this case, a "Pokemon" object.</li>
        <li><strong>entity</strong>: An entity is a value wrapped in a <code
                  class="language-typescript">Entity&lt;T></code> object.</li>
    </ul>

    <h1 id="state">State</h1>

    <p>
        Now that we have an entity, we can create our state. A state is composed by a type defined its shape and its
        initial value. Let's start by the shape of the state. In this example, it will simply contain a section called
        "pokemons". A section can be seen as a table in a database. It stores data of the same type.
    </p>

    <p>
        I usually create the state in a file called "app.state" located in a "states" directory.
    </p>

    <pre>
<code class="language-typescript">import {{ '{' }} Pokemon } from "../models/pokemon.model";

export type AppState = {{ '{' }}
    pokemons: Entities&lt;Pokemon>;
}</code></pre>

    <p>
        Along with the shape of the state, we need to defined its initial value. In the same file, add the following
        lines:
    </p>

    <pre>
<code class="language-typescript">import {{ '{' }} createEntities, Entities } from "@ssougnez/ng-store";
    
    export const initial: AppState = {{ '{' }}
        pokemons: createEntities()
    }</code></pre>

    <p>
        "createEntities" is a function that creates an empty section in your store.
    </p>

    <h1 id="configuration">Configuration</h1>

    <p>
        The last step required to use the start is simply to inject it in your module and configure it to use the
        default value of your store.
    </p>

    <p class="message information">
        As ng-store is not yet standalone compatible, you have to import "NgStoreModule" in the components using it.
        However, the standalone support is one of the next feature planned.
    </p>

    <pre>
<code class="language-typescript">@NgModule({{ '{' }}
    imports: [
      NgStoreModule
    ],
    providers: [
      {{ '{' }}
        provide: NG_STORE_CONFIG,
        useValue: {{ '{' }}
          initialValue: initial
        } as StoreConfiguration
      }
    ]
  })
  export class AppModule {{ '{' }} }
</code></pre>

    <p>
        The configuration object accepts other properties but we'll cover them later in this documentation.
    </p>

    <h1 id="find">Find functions</h1>

    <p>
        Find functions are used to find entities or values in the store. Let's start by updating the initial state of
        the store in order to insert some data.
    </p>

    <pre>
<code class="language-typescript">export const initial: AppState = {{ '{' }}
    pokemons: createEntities&lt;Pokemon>([
        {{ '{' }}
            id: 1,
            name: 'Pikachu',
            type: 'electric'
        },
        {{ '{' }}
            id: 2,
            name: 'Bulbasaur',
            type: 'grass'
        },
        {{ '{' }}
            id: 3,
            name: 'Charmander',
            type: 'fire'
        },
        {{ '{' }}
            id: 4,
            name: 'Charmander',
            type: 'fire'
        },
        {{ '{' }}
            id: 5,
            name: 'Squirtle',
            type: 'water'
        },
        {{ '{' }}
            id: 6,
            name: 'Caterpie',
            type: 'bug'
        },
        {{ '{' }}
            id: 7,
            name: 'Weedle',
            type: 'bug'
        },
        {{ '{' }}
            id: 8,
            name: 'Pidgey',
            type: 'normal'
        },
        {{ '{' }}
            id: 9,
            name: 'Nidoran',
            type: 'normal'
        },
        {{ '{' }}
            id: 10,
            name: 'Rattata',
            type: 'normal'
        },
        {{ '{' }}
            id: 11,
            name: 'Spearow ',
            type: 'normal'
        },
        {{ '{' }}
            id: 12,
            name: 'Ekans ',
            type: 'poison'
        }
    ])
}</code></pre>

    <p>
        Here's the ncessary code used to retrieve all the pokemons from the store:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent {{ '{' }}

  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public pokemons: Pokemon[] = this._store.getValues(s => s.pokemons);
  public trackByValue: TrackByFunction&lt;Pokemon> = trackByValue;

}</code></pre>

    <p>
        We're using the <code class="language-typescript">getValues</code> function to returns all the values stored in
        the "pokemons" section of the store. The <code class="language-typescript">trackByValue</code> variable is a
        function proposed by ng-store to tell <code class="language-typescript">ngFor</code> to use the "id" property of
        array values.
    </p>

    <pre>
<code class="language-xml">&lt;h1>Pokemon&lt;/h1>

&lt;div *ngFor="let pokemon of pokemons; trackBy: trackByValue">{{ '{' + '{' }} pokemon.name }}&lt;/div></code></pre>

    <p>The result being:</p>

    <div class="img">
        <img src="assets/img/get-values.png" />
    </div>

    <p>
        Now, to understand the difference between an entity and its value, let's use this variation of the code:
    </p>

    <pre>
<code class="language-typescript">export class AppComponent {{ '{' }}

  private readonly _store: NgStore&lt;AppState> = inject(NgStore);

  public pokemons: Entity&lt;Pokemon>[] = this._store.getEntities(s => s.pokemons);
  public trackByEntity: TrackByFunction&lt;Entity&lt;Pokemon>> = trackByEntity;

}</code></pre>

    <pre>
<code class="language-xml">&lt;h1>Pokemon&lt;/h1>
    
&lt;div *ngFor="let pokemon of pokemons; trackBy: trackByEntity">{{ '{' + '{' }} pokemon | json }}&lt;/div></code></pre>

    <p>
        This time, the result is:
    </p>

    <div class="img">
        <img src="assets/img/get-entities.png" />
    </div>

    <p>
        As you can see, an entity is an object with a <code class="language-typescript">value</code> property that
        contains the actual object you want to use. It also contains other properties used by "ng-store" to maintain the
        store in a correct state. Besides, we'll see later in this document that you can use some of these properties to
        update the UI of your component depending on the state of the entities in the store.
    </p>

    <p class="message information">
        In this case, we used <code class="language-typescript">trackByEntity</code> as we're dealing with entities.
    </p>

    <p>
        It is also possible to find a value or an entity in the store based on its "id" using the <code
              class="language-typescript">findValueByKey</code> or <code
              class="language-typescript">findEntityByKey</code>. For example, here is how you would find the pokemon
        with the "id" 1.
    </p>

    <pre>
<code class="language-typescript">public firstValue: Pokemon | null = this._store.findValueByKey(s => s.pokemons, 1);
public firstEntity: Entity&lt;Pokemon> | null = this._store.findEntityByKey(s => s.pokemons, 1);</code></pre>

    <p>
        Note that these functions return <code class="language-typescript">null</code> if the entity cannot be found.
    </p>

    <p>
        It is also possible to find values by any other criteria using the functions <code
              class="language-typescript">findValuesBy</code> or <code
              class="language-typescript">findEntitiesBy</code>. In the following example, we'll find all "normal"
        pokemons.
    </p>

    <pre>
<code class="language-typescript">public normalValues: Pokemon[] = this._store.findValuesBy(s => s.pokemons, p => p.type === 'normal');
public normalEntities: Entity&lt;Pokemon>[] = this._store.findEntitiesBy(s => s.pokemons, e => e.value.type === 'normal');</code></pre>

    <p class="message warning">
        Even though the code above works, it's recommanded and more performant to use <a href="#indexes">indexes</a> as
        much as possible to find values based on another property than the "id".
    </p>

    <p>
        You can also use the functions <code class="language-typescript">findEntityBy</code> and <code
              class="language-typescript">findValueBy</code> to find the first entity or value matching the condition.
    </p>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/01_Find"
           target="_blank">the first example</a> of the playground.
    </p>

    <h1 id="select">Select functions</h1>

    <p>
        In the previous chapter, we saw how to retrieve values from the store. Even though it works, there is something
        you need be aware of: The store is <strong>immutable</strong>. You can confirm this by trying to do something
        like this:
    </p>

    <pre>
<code class="language-typescript">let pokemon: Pokemon | null = this._store.findValueByKey(s => s.pokemons, 1);

if (pokemon !== null) {{ '{' }}
  pokemon.name = 'Super pikachu';
}</code></pre>

    <p>
        The code above would produce the following error in the console:
    </p>

    <div class="img">
        <img src="assets/img/immutable-error.png" />
    </div>

    <p>
        Indeed, values in the store are <strong>immutable</strong>, which means that you cannot directly update them
        like
        in the example above. If you never used immutability, it can seem weird but I strongly advice you to read on the
        subject to understand why it is a better idea to store the object like this.
    </p>

    <p>
        There are multiple ways to ensure immutability in JavaScript and ng-store uses an awesome library called <a
           href="https://github.com/immerjs/immer"
           target="_blank">immer</a>. I won't talk about this library in here but I strongly advice you to have a look
        at it if you want to understand how ng-store works under the hood.
    </p>

    <p>
        One important consequence of immutability is that objects that you retrieve from the store using <a
           href="find">find functions</a> might not always display the most up to date data. Indeed, say you
        get a value from the store using a find function. If this value changes in the store, your component will still
        hold a reference to the same object, so the one that hasn't been modified (as the modification triggers the
        creation of a new object), so you need to have a way to know when a value is modified in order to refresh your
        component accordingly, which is exactly what select functions are for.
    </p>

    <p>
        Basically, select functions are the same than find functions but they return observables instead of values or
        entities. For example:
    </p>

    <pre>
<code class="language-typescript">public values$: Observable&lt;Pokemon[]> = this._store.selectValues(s => s.pokemons);
public entities$: Observable&lt;Entity&lt;Pokemon>[]> = this._store.selectEntities(s => s.pokemons);</code></pre>

    <p>
        As you can see, you use <code class="language-typescript">selectValues</code> and <code
              class="language-typescript">selectEntities</code> the same way you use <code
              class="language-typescript">getValues</code> and <code class="language-typescript">getEntities</code>. The
        only difference is that these functions return an observable instead of the values or entities. As for the
        templates, the code is almost the same.
    </p>

    <pre>
<code class="language-xml">&lt;h1>Values&lt;/h1>

&lt;div *ngFor="let pokemon of values$ | async; trackBy: trackByValue">{{ '{' + '{' }} pokemon | json }}&lt;/div>

&lt;h1>Entities&lt;/h1>

&lt;div *ngFor="let pokemon of entities$ | async; trackBy: trackByEntity">{{ '{' + '{' }} pokemon | json }}&lt;/div></code></pre>

    <p>
        The only difference here is that you have to use the <code class="language-typescript">async</code> pipe.
    </p>

    <p>
        Using the select functions, you ensure that your component will be notified each time a values that you
        retrieved changes. Another big advantage is that you can use the <code class="language-typescript">async</code>
        pipe to refresh the view of the component in a way supported by the "OnPush" change detection strategy.
    </p>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/02_Select"
           target="_blank">the second example</a> of the playground.
    </p>

    <h1 id="indexes">Indexes</h1>

    <p>
        In the previous example, we saw how to select values based on another critera than their key. Even though it
        works, it's not optimal for performances. For example:
    </p>

    <pre>
<code class="language-typescript">public normal: Observable&lt;Pokemon[]> = this._store.selectValuesBy(s => s.pokemons, p => p.type === 'normal');</code></pre>

    <p>
        The issue here is that when the store gets updated, it will emit its new value, therefore, the predicate above
        will get executed for all pokemons once again.. If there are less than 10 000 items, it should be pretty fast,
        however, if your store contains a huge amount of pokemons, it can be pretty intensive to examine all of them to
        only return the normal ones. In this case, it is recommended to use indexes instead. Basically, an index is
        a property of the object that the store uses to organize its content in an efficient way.
    </p>

    <p>
        The first thing to do in order to use indexes is to define them when using <code
              class="language-typescript">createEntities</code>:
    </p>

    <pre>
<code class="language-typescript">export const initial: AppState = {{ '{' }}
    pokemons: createEntities&lt;Pokemon>([ ... ], ['type'])
}</code></pre>

    <p>
        Indexes are defined using the second parameter of <code class="language-typescript">createEntities</code> by
        passing an array of property names that will be used as indexes. It can be tempting to define every property
        in there but it is better to only defines the ones you'll really be using the most. Indeed, even though ng-store
        supports multiple indexes, maintaining them has a small cost, so it's better to avoid it if you don't need it.
    </p>

    <p>
        Now that we defined our index, we can simply used it via the functions <code
              class="language-typescript">findValuesByIndex</code> or <code
              class="language-typescript">selectValuesByIndex</code>:
    </p>

    <pre>
<code class="language-typescript">public normal: Observable&lt;Pokemon[]> = this._store.selectValuesByIndex(s => s.pokemons, 'type', 'normal');</code></pre>

    <p class="message information">
        You can find the code of this section in <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src/examples/03_Indexes"
           target="_blank">the third example</a> of the playground.
    </p>

</main>