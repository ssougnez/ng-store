<main>

    <div class="logo">

        <div class="title">
            <span>ng-st</span>
            <img src="assets/img/logo.svg"
                 alt="Logo" />
            <span>re</span>
        </div>
    </div>

    <h1>Table of content</h1>

    <ul>
        <li><a href="#context">Context</a></li>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#playground">PLayground</a></li>
        <li><a href="#installation">Installation</a></li>
        <li><a href="#principle">Principle</a></li>
        <li><a href="#models">Models</a></li>
        <li><a href="#state">State</a></li>
        <li><a href="#configuration">Configuration</a></li>
        <li><a href="#getting-started">Getting started</a></li>
    </ul>

    <h1 id="context">Context</h1>

    <p>Managing data in an Angular application can be quite tricky and impact the way you develop your application.
        "ng-store" is a solution to manage data using a store similar to a relational database.</p>

    <h1 id="introduction">Introduction</h1>

    <p>When learning Angular, you'll be confronted to a lot of concepts and challenges that you'll have to take.
        There are so many of those that beginners tend to neglect one of the most important: data management.</p>

    <p>At first, it's tempting to rush into components development to make huge and complex components to power your
        application. After all, at first, it seems easier to have everything in a huge component. However, after a
        while, it appears that it is not a good solution and that it brings more problem that it solves.</p>

    <p>At some point, in the Angular learning journey, one will be confronted to the challenge of managing data in the
        best way possible. At first, it's most likely that one will store data inside a component. Basically, after
        having read some tutorials, one will inject the <code class="language-typescript">HttpClient</code> service into
        the component and call the <code class="language-typescript">get</code> method to fetch data before displaying
        them on the screen.</p>

    <p>It obviously works pretty well, however, there are some attention points to this:</p>

    <ul>
        <li>
            In a perfect world, a component should do one and only one thing. Therefore, fetching data using a HTTP call
            and displaying them could be considered as two things => bad practice.
        </li>
        <li>
            Data loaded in the component are only available in this component.
        </li>
        <li>
            You might need multiple class variables to store these data depending on the complexity of the component.
        </li>
        <li>
            If multiple components need the same data, they will be loaded multiple times.
        </li>
    </ul>

    <p>The next logical step is to start using services to store data. There are avantages to this approach:</p>

    <ul>
        <li>
            Data are centralized: When data are loaded, they are available to multiple components.
        </li>
        <li>
            The heavy lifting is done once by the service. Components needing the data just have to inject the
            service and use the data.
        </li>
    </ul>

    <p>
        However, it's still, in my opinion, not the perfect solution. Indeed, with services maintaining their own data
        arise some pain points:
    </p>

    <ul>
        <li>
            What if the service A needs data from the services B and vice versa. This will create a cyclic dependency
            that will be difficult to solve properly.
        </li>
        <li>
            It's difficult to ensure that services fetch and maintain their data in the same way. This can be leveraged
            using a base class but it adds some complexity.
        </li>
        <li>
            If you're using the "OnPush" change detection strategy (as you should), simply updating data in a service
            won't refresh the views that depend on its data. Indeed, you'll need to implement a system propagating the
            value change down to the components. It's not very complex but it adds unecessary boilerplate.
        </li>
        <li>
            You still have to think and implement a way of fetching data from your back end in a consistent way.
        </li>
    </ul>

    <p>
        I faced all these issues and considerations in my day to day work for a while, which is why I decided to have a
        look at store/state management systems out there.
    </p>

    <p>To be honest, I only checked one out: <a href="https://ngrx.io/"
           target="_blank">ngrx</a>. Mostly because it's the most popular one.
    </p>

    <p>
        Before reading the following lines, please consider that I didn't use it for a long time and I probably only
        scratched the surface so the following lines might not be entirely correct or can be outdated.
    </p>

    <p>
        My general feeling about this library is that it is waaay too complex to use. You have to create actions,
        effects, reducers, selectors, etc... and at the end, everything ties up magically and it becomes pretty
        cumbersome to have a clear view of what's happening in your application or to debug it.
    </p>

    <p>
        Another issue I had with it was the way immutability is handled. Basically, you have to do the heavy lifting
        using the spread operator in order to create new objects based on existing ones. I found it pretty cumbersome
        and not very intuitive (spoiler alert: "ng-store" handles it in a way that is totally transparent to you).
    </p>

    <p>
        Once again, I'm sure it's a perfectly good library but long story short, it didn't suit me.
    </p>

    <p>
        However, I really liked the idea of having one common location to store all the data of the application.
        Besides, the reactivity of the store also charmed me a lot, which is why I decided to implement my own store
        management library.
    </p>

    <p>
        At the time of writing (2023), I've been working on and using this library for two years and now that it is
        stable, I feel that it can be useful to other developers than me.
    </p>

    <p>
        In this documentation, we'll see the basic principle behind ng-store, how to configure and use it. After
        reading, you'll know everything there is about it and if you liked what you read, maybe you'll want to use it in
        your app ðŸ˜€
    </p>

    <h1 id="playground">Playground</h1>

    <p>You can find the code of the examples we'll talk about later in this article in the <a
           href="https://github.com/ssougnez/ng-store/tree/main/ng-store-playground/src"
           target="_blank">GitHub playground</a>. The only thing you need to do is update the line 6 of the "main.ts"
        file to change the example you want to build.</p>

    <h1 id="installation">Installation</h1>

    <p>Simply run:</p>

    <pre><code class="language-typescript">yarn add immer @ssougnez/ng-store</code></pre>

    <h1 id="principle">Principle</h1>

    <p>
        You can use "ng-store" the way you want, however, you'll find in this section some advices to use it in an
        optimal way.
    </p>

    <p>
        Basically, the main principle consists in using "flat objects" as musch as possible. What I call "flat objects"
        are objects without any complex properties other than ones containing abstract data. For example, this is not a
        "flat object":</p>

    <pre>
<code class="language-typescript">{{ '{' }}
    firstName: "Nicolas",
    lastName: "Cage",
    age: 50,
    friends: [{{ '{' }}
        firstName: "Nicole",
        lastName: "Kidman",
        age: 56
    }]
}</code></pre>

    <p>
        The issue with this kind of objet is that it is an open door to data redundancy. Indeed, say that you fetch
        these data from a back end using REST API. It is very likely that the different users will have the same
        friends, meaning that a user data might be located in the "friends" array of multiple objects, causing the data
        to be bigger and duplicated. A better version of it would be:
    </p>

    <pre>
<code class="language-typescript">{{ '{' }}
    firstName: "Nicolas",
    lastName: "Cage",
    age: 50,
    friends: [3, 19, 5]
}</code></pre>

    <p>
        In this approach, objects are treated as <strong>entities</strong> identified by a specific property that do not
        contain complex properties other than abstract data. "Abstract data" are data that does not represent entities
        in themselves, for example, some configuration for a specific entity.
    </p>

    <p>
        Basically, you have to think about entities as rows in a relational database. In these, you have regular columns
        storing simple data and when you need more complex data, you store them in another table referenced by a foreign
        key in your primary one. In some circunstance, you'll also create a text column storing abstract data (in JSON).
    </p>

    <p>
        Following this principle will help you a lot using "ng-store", but also for working on your back end. Indeed,
        when you have no real guidelines about the form of the object to return via a web service, it can be difficult
        to know what data to fetch from the database because you're not sure what data will be needed by the REST API
        call. With this approach, most of the time, you'll fetch data from your database in the most basic way.
    </p>

    <h1 id="models">Models</h1>

    <p>
        The core concept of the store is "entities". As explained above, an entity is a basic object with only
        simple properties. It must also contain an "id" property of the type you want. To ensure this last requirement,
        all your entities need to extend the <code class="language-typescript">BaseEntity&lt;T></code> base class
        where "T" is the type of the "id" property. For example, here is an example of a "Pokemon" entity.
    </p>

    <pre>
<code class="language-typescript">import {{ '{' }} BaseEntity } from "@ssougnez/ng-store";

export type Pokemon = BaseEntity&lt;number> & {{ '{' }}
    name: string;
    type: 'water' | 'fire' | 'electric';
}</code></pre>

    <h1 id="state">State</h1>

    <p>
        Now that we have an entity, we can create our state. A state is composed by a type defined its shape and its
        initial value. Let's start by the shape of the state. In this example, it will simply contain a section called
        "pokemons". A section can be seen as a table in a database. It stores data of the same type.
    </p>

    <p>
        I usually create the state in a file called "app.state" located in a "states" directory.
    </p>

    <pre>
<code class="language-typescript">import {{ '{' }} Pokemon } from "../models/pokemon.model";

export type AppState = {{ '{' }}
    pokemons: Entities&lt;Pokemon>;
}</code></pre>

    <p>
        Along with the shape of the state, we need to defined its initial value. In the same file, add the following
        lines:
    </p>

    <pre>
<code class="language-typescript">import {{ '{' }} createEntities, Entities } from "@ssougnez/ng-store";
    
    export const initial: AppState = {{ '{' }}
        pokemons: createEntities()
    }</code></pre>

    <p>
        "createEntities" is a function that creates an empty section in your store.
    </p>

    <h1 id="configuration">Configuration</h1>

    <p>
        The last step required to use the start is simply to inject it in your module and configure it to use the
        default value of your store.
    </p>

    <p class="message information">
        As ng-store is not yet standalone compatible, you have to import "NgStoreModule" in the components using it.
        However, the standalone support is one of the next feature planned.
    </p>

    <pre>
<code class="language-typescript">@NgModule({{ '{' }}
    imports: [
      NgStoreModule
    ],
    providers: [
      {{ '{' }}
        provide: NG_STORE_CONFIG,
        useValue: {{ '{' }}
          initialValue: initial
        } as StoreConfiguration
      }
    ]
  })
  export class AppModule {{ '{' }} }
</code></pre>

    <p>
        The configuration object accepts other properties but we'll cover them later in this documentation.
    </p>


    <h1 id="select-find">Select and find value(s)</h1>

    <!--
    <p>Now that the store is configured, we'll see how to select, add, update and remove data from it. Let's imagine
        this very simple component:</p>

    <pre><code class="language-typescript">&lt;pre>{{ '{' + '{' }} pokemons$ | async | json }}&lt;/pre>

&lt;button (click)="add()">Add&lt;/button>
&lt;button (click)="update()">Edit&lt;/button>
&lt;button (click)="remove()">Reset&lt;/button></code></pre>

    <p>So basically, we just display the values emitted by the "pokemons$" observable above 3 buttons used to
        respectively
        add, update and remove data from the store.</p>

    <p>Let's start with the code used to retrieves pokemons from the store:</p>

    <pre><code class="language-typescript">export class AppComponent {{ '{' }}

    public store: NgStore&lt;AppState> = inject(NgStore);
  
    public pokemons$: Observable&lt;Pokemon[]> = this.store.selectValues(s => s.pokemons);
  
}</code></pre>

    <p>You just need to call the "selectValues" function of the store in order to retrieve an observables of this
        section of
        the store. This means that each time something in this section will change, the observable will emit the new
        value.
        In this case, we simply watch for all the pokemons of the store.</p>

    <p>Now the code to add data in the store:</p>

    <pre><code class="language-typescript">public add() {{ '{' }}
    this.store.upsertValue&lt;Pokemon>(s => s.pokemons, {{ '{' }} id: 1, name: 'Pikachu', type: 'electric' });
}</code></pre>

    <p>Adding data in the store can be done using the `upsertValue`. This function adds or update an entity in the store
        based on its ID. You have to use it to add data into the store but you can update data from it in a different
        way,
        which is what we do in the "update" function:</p>

    <pre><code class="language-typescript">public update() {{ '{' }}
    this.store.updateValueByKey&lt;Pokemon>(s => s.pokemons, 1, p => p.name = 'Dracofeu');
}</code></pre>

    <p>The difference between the `updateValueByKey` and the `upsertValue` is that the former one will give you access
        to
        the object you want to update and you'll be able to updte it the way you want, while the latter is generally use
        when you already have an object containing the properties to update. Most of the time, you'll use `upsertValue`
        but
        `updateValueByKey` can also be pretty handy.
    </p>

    <p>One thing important to mention here is that object in the store <strong>are</strong> immutable. In the example
        above,
        the way the object is updated might look like entities are mutable but it is not the case. Indeed, "ng-store" is
        using the awesome <a href="https://github.com/immerjs/immer"
           target="_blank">immer</a> library used that leverage JavaScript proxies in order to handle immutability in a
        very
        handy way.</p>

    <p>Finally, the "remove" function:</p>

    <pre><code class="language-typescript">public remove() {{ '{' }}
    this.store.removeEntitiesByKeys&lt;Pokemon>(s => s.pokemons, 1);
}</code></pre>

-->

    <p>The rest is coming soon...</p>
</main>